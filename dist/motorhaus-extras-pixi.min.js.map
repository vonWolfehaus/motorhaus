{"version":3,"sources":["Camera2.js","TileMap2.js","Vec2.js","FlowGrid.js","Emitter.js","steering.js","VectorFieldState.js","BoidGroup.js","Boid.js","PIXISprite.js"],"names":["mh","Camera2","settings","Base","call","this","width","kai","height","scalable","scale","minScale","maxScale","scalePadding","target","targets","displayObject","deadzone","bounds","Rectangle","world","util","overwrite","position","Vec2","atLimit","x","y","_edge","FOLLOW_LOCKON","FOLLOW_PLATFORMER","FOLLOW_TOPDOWN_LOOSE","FOLLOW_TOPDOWN","FOLLOW_TOPDOWN_TIGHT","prototype","follow","style","Object","toString","console","log","helper","w","h","Math","max","focusOn","setPosition","round","focusOnXY","update","updateTarget","checkBounds","i","minX","minY","maxX","maxY","rx","ry","pos","t","len","lastActive","activeLen","length","Number","MAX_VALUE","MIN_VALUE","active","setBoundsToWorld","setTo","right","top","bottom","floor","setSize","TileMap2","tileSize","tilesprite","widthInTiles","heightInTiles","numTiles","grid","_blockCache","LinkedList","_blockLookup","_ctx","_sizeMulti","constuctor","setTile","forceValue","idx","tile","block","px","py","clearRect","add","disable","drawImage","pop","Block","collider","setMass","enable","getTile","clear","id","str","split","parseInt","v","substring","draw","ctx","v1","v2","drawingColor","camOffsetX","camOffsetY","strokeStyle","beginPath","moveTo","lineTo","stroke","constructor","setLength","value","oldLength","getLength","multiplyScalar","sqrt","getLengthSq","setAngle","getAngle","cos","sin","atan2","rotateBy","theta","addScalar","s","subtract","subtractScalar","multiply","divide","divideScalar","perp","nx","negate","clamp","min","dotProduct","crossProd","truncate","l","angleTo","dx","dy","distanceTo","distanceToSquared","lerp","alpha","normalize","set","equals","copy","clone","startX","startY","FlowGrid","cellSize","cellPixelSize","widthInCells","heightInCells","numCells","goal","goalPixels","_openList","j","FlowGridNode","flow","setGoal","endPixelX","endPixelY","endX","endY","Error","activate","build","current","node","neighbor","a","b","open","cost","shift","gridX","gridY","passable","vx","vy","lineWidth","fillStyle","arc","TAU","fill","getVectorAt","setBlockAt","gx","gy","uniqueID","Date","now","random","Emitter","entity","container","stage","blend","emitType","EmitType","Point","emitDuration","emitAngle","emitAngleVar","emitSpeed","emitSpeedVar","emitRate","particleDuration","particleDurationVar","particleScaleInit","particleScaleVar","particleAlphaInit","particleAlphaAccel","particleAlphaAccelDelay","particleRotationAccel","particleRotationAccelVar","particleRadialAccel","particleRadialAccelVar","particleTangentialAccel","particleTangentialAccelVar","particleGravity","duration","uri","texture","PIXI","Texture","fromImage","generateID","_force","_vec","_emitTimer","_pool","DualPool","Particle","_emissionSum","create","SpriteBatch","accessor","className","priority","addChild","visible","elapsed","removeChild","freeAll","p","o","busy","emit","first","obj","next","recycle","fadeDelay","radialAccel","tangentialAccel","rotation","rotationAccel","dispose","removeChildren","destroy","forces","amt","ii","Type","get","blendMode","blendModes","ADD","NORMAL","Rect","randomInt","_width","_height","Circle","CircleUniform","Ring","parent","Sprite","addChildAt","anchor","steering","_sumForce","_desiredVec","_scratchVec","_wanderVec","_seperationForce","_cohereForce","_alignForce","_wanderAngle","seek","agent","dest","slowingRadius","distance","velocity","maxForce","steeringForce","flee","align","flock","neighboursCount","boid","groupID","maxCohesion","_arrived","cohere","separate","minSeparation","r","wander","targetDistance","reset","targetRadius","angleJitter","followPath","path","repeat","_currentPathNode","pathArriveRadius","_pathDir","pursue","targetAgent","evade","pursuingAgent","VectorFieldState","fieldID","reachedGoal","addComponent","Component","FLOCK","Flock","_position","_vecField","_pollTime","_timer","ceil","nearby","vecFieldState","BoidGroup","members","_nodePool","STACK_FSM","onComplete","Signal","stackFSM","stateChanged","_stateChanged","DETACHED","ATTACHED","addBoid","addEntity","warn","addEntities","list","removeBoid","remove","dispatch","removeEntity","removeAll","addWaypoint","push","pushState","setPath","newPath","removeComponent","Steering","popState","oldState","newState","groupControl","Boid","flockRadius","maxSpeed","body","expect","post","invmass","PIXISprite","textureUrl","view","_display"],"mappings":"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","file":"motorhaus-extras-pixi.min.js","sourcesContent":["/**\n * A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.\n * The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Camera.\n * @author Richard Davey (Phaser)\n * @author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n */\n mh.Camera2 = function(settings) {\n\tsettings = settings || {};\n\tmh.Base.call(this);\n\n\t// attributes\n\tthis.width = mh.kai.width;\n\tthis.height = mh.kai.height;\n\tthis.scalable = false; // scale if there are multiple targets and they get outside of view\n\tthis.scale = 1;\n\tthis.minScale = 0.3; // how far it can zoom out\n\tthis.maxScale = 1; // how far to zoom in\n\tthis.scalePadding = 100;\n\tthis.target = null;\n\tthis.targets = null;\n\t// {x, y, scaleX, scaleY} reference to the object that gets moved around by the camera to give the impression of a world larger than the screen.\n\tthis.displayObject = null;\n\t// {Rectangle} Moving inside this Rectangle will not cause camera moving.\n\tthis.deadzone = null;\n\n\t/**\n\t * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.\n\t * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound\n\t * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the center of the world.\n\t * @property {Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.\n\t */\n\tthis.bounds = new mh.Rectangle(0, 0, mh.world.width, mh.world.height);\n\n\tmh.util.overwrite(this, settings);\n\n\t// base components\n\tthis.position = new mh.Vec2();\n\t// this.velocity = new mh.Vec2();\n\n\t/**\n\t * @property {boolean} atLimit - Whether this camera is flush with the World Bounds or not.\n\t */\n\tthis.atLimit = { x: false, y: false };\n\n\tthis._edge = 0;\n\n\t// console.log(this.scalable);\n};\n\nmh.Camera2.FOLLOW_LOCKON = 0;\nmh.Camera2.FOLLOW_PLATFORMER = 1;\nmh.Camera2.FOLLOW_TOPDOWN_LOOSE = 2;\nmh.Camera2.FOLLOW_TOPDOWN = 3;\nmh.Camera2.FOLLOW_TOPDOWN_TIGHT = 4;\n\nmh.Camera2.prototype = {\n\n\t/**\n\t * Tells this camera which sprite to follow.\n\t * @method Camera#follow\n\t * @param {Sprite} target - Vec2 or array of entities with positions to track. Set to null to not follow anything.\n\t * @param {number} [style] Leverage one of the existing 'deadzone' presets. If you use a custom deadzone, ignore this parameter and manually specify the deadzone after calling follow().\n\t */\n\tfollow: function(target, style) {\n\t\tif (typeof style === 'undefined') {\n\t\t\tstyle = mh.Camera2.FOLLOW_TOPDOWN;\n\t\t}\n\n\t\tif (Object.prototype.toString.call(target) === '[object Array]') {\n\t\t\tconsole.log('[Camera2.follow] Tracking multiple targets');\n\t\t\tthis.target = new mh.Vec2();\n\t\t\tthis.targets = target;\n\t\t}\n\t\telse {\n\t\t\tthis.target = target;\n\t\t}\n\n\t\tvar helper;\n\n\t\tswitch (style) {\n\t\t\tcase mh.Camera2.FOLLOW_PLATFORMER:\n\t\t\t\tvar w = this.width / 8;\n\t\t\t\tvar h = this.height / 3;\n\t\t\t\tthis.deadzone = new mh.Rectangle((this.width - w) / 2, (this.height - h) / 2 - h * 0.25, w, h);\n\t\t\t\tbreak;\n\n\t\t\tcase mh.Camera2.FOLLOW_TOPDOWN_LOOSE:\n\t\t\t\thelper = Math.max(this.width, this.height) / 2;\n\t\t\t\tthis.deadzone = new mh.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);\n\t\t\t\tbreak;\n\n\t\t\tcase mh.Camera2.FOLLOW_TOPDOWN:\n\t\t\t\thelper = Math.max(this.width, this.height) / 4;\n\t\t\t\tthis.deadzone = new mh.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);\n\t\t\t\tbreak;\n\n\t\t\tcase mh.Camera2.FOLLOW_TOPDOWN_TIGHT:\n\t\t\t\thelper = Math.max(this.width, this.height) / 8;\n\t\t\t\tthis.deadzone = new mh.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);\n\t\t\t\tbreak;\n\n\t\t\tcase mh.Camera2.FOLLOW_LOCKON:\n\t\t\t\tthis.deadzone = null;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.deadzone = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t},\n\n\t/**\n\t* Move the camera focus on a display object instantly.\n\t* @method Camera2#focusOn\n\t* @param {any} displayObject - The display object to focus the camera on. Must have visible x/y properties.\n\t*/\n\tfocusOn: function(displayObject) {\n\t\tthis.setPosition(Math.round(displayObject.x - (this.width*0.5)), Math.round(displayObject.y - (this.height*0.5)));\n\t},\n\n\t/**\n\t* Move the camera focus on a location instantly.\n\t* @method Camera2#focusOnXY\n\t* @param {number} x - X position.\n\t* @param {number} y - Y position.\n\t*/\n\tfocusOnXY: function(x, y) {\n\t\tthis.setPosition(Math.round(x - (this.width*0.5)), Math.round(y - (this.height*0.5)));\n\t},\n\n\t/**\n\t* Update focusing and scrolling.\n\t* @method Camera2#update\n\t*/\n\tupdate: function() {\n\t\tif (this.target) {\n\t\t\tthis.updateTarget();\n\t\t}\n\n\t\tif (this.bounds) {\n\t\t\tthis.checkBounds();\n\t\t}\n\n\t\tif (this.scalable) {\n\t\t\tthis.displayObject.scale.x = this.scale;\n\t\t\tthis.displayObject.scale.y = this.scale;\n\t\t}\n\n\t\t// this.displayObject.position.x = -this.position.x;\n\t\t// this.displayObject.position.y = -this.position.y;\n\t\tthis.displayObject.x = -this.position.x;\n\t\tthis.displayObject.y = -this.position.y;\n\t},\n\n\tupdateTarget: function() {\n\t\tvar i, minX, minY, maxX, maxY, w, h, rx, ry, pos,\n\t\t\tt, len, lastActive, activeLen;\n\n\t\t// loop through all the targets to find bounding area\n\t\tif (this.targets) {\n\t\t\tlen = this.targets.length;\n\t\t\tactiveLen = 0;\n\n\t\t\tminX = Number.MAX_VALUE, minY = Number.MAX_VALUE;\n\t\t\tmaxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tt = this.targets[i];\n\t\t\t\tif (t.active) {\n\t\t\t\t\tactiveLen++;\n\t\t\t\t\tlastActive = t;\n\t\t\t\t\tpos = t.position;\n\t\t\t\t\tif (pos.x < minX) minX = pos.x;\n\t\t\t\t\tif (pos.y < minY) minY = pos.y;\n\t\t\t\t\tif (pos.x > maxX) maxX = pos.x;\n\t\t\t\t\tif (pos.y > maxY) maxY = pos.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (activeLen > 1) {\n\t\t\t\tthis.target.x = (minX + maxX) * 0.5;\n\t\t\t\tthis.target.y = (minY + maxY) * 0.5;\n\n\t\t\t\tif (this.scalable) {\n\t\t\t\t\tthis.scale = 1;\n\n\t\t\t\t\tw = maxX - minX + this.scalePadding;\n\t\t\t\t\th = maxY - minY + this.scalePadding;\n\n\t\t\t\t\trx = w === 0 ? 1 : mh.kai.width / w;\n\t\t\t\t\try = h === 0 ? 1 : mh.kai.height / h;\n\t\t\t\t\tif (rx < ry) {\n\t\t\t\t\t\tthis.scale = rx;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.scale = ry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.scale < this.minScale) {\n\t\t\t\t\t\tthis.scale = this.minScale;\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.scale > this.maxScale) {\n\t\t\t\t\t\tthis.scale = this.maxScale;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.target.x *= this.scale;\n\t\t\t\t\tthis.target.y *= this.scale;\n\n\t\t\t\t\t// DebugDraw.circle(this.target.x - this.position.x, this.target.y - this.position.y, 2);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (activeLen === 1) {\n\t\t\t\tthis.target.x = lastActive.position.x;\n\t\t\t\tthis.target.y = lastActive.position.y;\n\t\t\t\tthis.scale = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (this.deadzone) {\n\t\t\tthis._edge = this.target.x - this.deadzone.x;\n\t\t\tif (this.position.x > this._edge) {\n\t\t\t\tthis.position.x = this._edge;\n\t\t\t}\n\n\t\t\tthis._edge = this.target.x - this.deadzone.x - this.deadzone.width;\n\t\t\tif (this.position.x < this._edge) {\n\t\t\t\tthis.position.x = this._edge;\n\t\t\t}\n\n\t\t\tthis._edge = this.target.y - this.deadzone.y;\n\t\t\tif (this.position.y > this._edge) {\n\t\t\t\tthis.position.y = this._edge;\n\t\t\t}\n\n\t\t\tthis._edge = this.target.y - this.deadzone.y - this.deadzone.height;\n\t\t\tif (this.position.y < this._edge) {\n\t\t\t\tthis.position.y = this._edge;\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tthis.focusOnXY(this.target.x, this.target.y);\n\t\t}\n\t},\n\n\tsetBoundsToWorld: function() {\n\t\tthis.bounds.setTo(0, 0, mh.world.width, mh.world.height);\n\t},\n\n\t/**\n\t* Method called to ensure the camera doesn't venture outside of the game world.\n\t* @method Camera2#checkWorldBounds\n\t*/\n\tcheckBounds: function() {\n\t\tthis.atLimit.x = false;\n\t\tthis.atLimit.y = false;\n\n\t\t//  Make sure we didn't go outside the cameras bounds\n\t\tif (this.position.x < this.bounds.x) {\n\t\t\tthis.atLimit.x = true;\n\t\t\tthis.position.x = this.bounds.x;\n\t\t}\n\n\t\tif (this.position.x > this.bounds.right - this.width) {\n\t\t\tthis.atLimit.x = true;\n\t\t\tthis.position.x = (this.bounds.right - this.width) + 1;\n\t\t}\n\n\t\tif (this.position.y < this.bounds.top) {\n\t\t\tthis.atLimit.y = true;\n\t\t\tthis.position.y = this.bounds.top;\n\t\t}\n\n\t\tif (this.position.y > this.bounds.bottom - this.height) {\n\t\t\tthis.atLimit.y = true;\n\t\t\tthis.position.y = (this.bounds.bottom - this.height) + 1;\n\t\t}\n\n\t\tthis.position.x = Math.floor(this.position.x);\n\t\tthis.position.y = Math.floor(this.position.y);\n\t},\n\n\t/**\n\t* A helper function to set both the X and Y properties of the camera at once\n\t* without having to use game.camera.x and game.camera.y.\n\t*\n\t* @method Camera2#setPosition\n\t* @param {number} x - X position.\n\t* @param {number} y - Y position.\n\t*/\n\tsetPosition: function(x, y) {\n\t\tthis.position.x = x;\n\t\tthis.position.y = y;\n\n\t\tif (this.bounds) {\n\t\t\tthis.checkBounds();\n\t\t}\n\t},\n\n\t/**\n\t* Sets the size of the view rectangle given the width and height in parameters.\n\t*\n\t* @method Camera2#setSize\n\t* @param {number} width - The desired width.\n\t* @param {number} height - The desired height.\n\t*/\n\tsetSize: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n};\n","/*\n\tSimple array 2D TileMap. Collision is done by adding/removing collider components to the system at grid positions that have less than 3 neighbors.\n\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh.TileMap2 = function(tileSize, tilesprite) {\n\tthis.widthInTiles = Math.floor(mh.kai.width / tileSize) + 1;\n\tthis.heightInTiles = Math.floor(mh.kai.height / tileSize) + 1;\n\n\tthis.numTiles = this.widthInTiles * this.heightInTiles;\n\tthis.grid = [];\n\n\t// internal\n\tthis._blockCache = new mh.LinkedList(),\n\tthis._blockLookup = {},\n\tthis._ctx = null,\n\tthis._sizeMulti = 1 / tileSize;\n\tthis.tileSize = tileSize;\n\tthis.tilesprite = tilesprite;\n\n\t/*var canvas = document.getElementById('tilemap');\n\tcanvas.width = window.innerWidth;\n\tcanvas.height = window.innerHeight;\n\tthis._ctx = canvas.getContext('2d');\n\n\tfor (var i = 0; i < _self.numTiles; i++) {\n\t\t_self.grid[i] = 0;\n\t}\n\n\tmh.kai.map = _self;\n\n\tconsole.log('[TileMap2] '+_self.widthInTiles+'x'+_self.heightInTiles);\n\t// console.log(_self.toString());*/\n};\n\nmh.TileMap2.prototype = {\n\tconstuctor: mh.TileMap2,\n\t/**\n\t * Add or remove a tile at the given pixel coordinates.\n\t * @returns [boolean] If a tile was changed.\n\t */\n\tsetTile: function(x, y, forceValue) {\n\t\tvar idx, tile, block, px, py;\n\n\t\tforceValue = forceValue || null;\n\t\tx = ~~(x * this._sizeMulti);\n\t\ty = ~~(y * this._sizeMulti);\n\t\tidx = (x * this.heightInTiles) + y;\n\t\tif (idx < 0 || idx >= this.numTiles) return false;\n\n\t\tpx = x * this.tileSize;\n\t\tpy = y * this.tileSize;\n\t\ttile = this.grid[idx];\n\t\tif (forceValue && tile === forceValue) return false;\n\t\t// console.log('[TileMap2.setTile] '+x+', '+y+'; '+tile);\n\n\t\tif (tile > 0) {\n\t\t\tthis.grid[idx] = 0;\n\t\t\tthis._ctx.clearRect(px, py, this.tileSize, this.tileSize);\n\n\t\t\t// kill the block\n\t\t\tblock = this._blockLookup[px+'-'+py];\n\t\t\tthis._blockCache.add(block);\n\t\t\tblock.disable();\n\t\t\tdelete this._blockLookup[px+'-'+py];\n\n\t\t}\n\t\telse {\n\t\t\tthis.grid[idx] = 1;\n\t\t\tthis._ctx.drawImage(this.tilesprite, px, py);\n\n\t\t\t// add a block to the grid\n\t\t\tif (this._blockCache.length) {\n\t\t\t\tblock = this._blockCache.pop();\n\t\t\t\tblock.position.x = px+25;\n\t\t\t\tblock.position.y = py+25;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tblock = new mh.Block(px+25, py+25);\n\t\t\t\tblock.collider.setMass(0);\n\t\t\t}\n\n\t\t\tblock.enable();\n\t\t\tthis._blockLookup[px+'-'+py] = block;\n\t\t}\n\n\t\t// console.log(this.toString());\n\t\treturn true;\n\t},\n\n\tgetTile: function(x, y) {\n\t\tvar idx;\n\t\tx = ~~(x * this._sizeMulti);\n\t\ty = ~~(y * this._sizeMulti);\n\t\tidx = (x * this.heightInTiles) + y;\n\t\tif (idx < 0 || idx >= this.numTiles) return null;\n\n\t\treturn this.grid[idx];\n\t},\n\n\tclear: function() {\n\t\tvar block;\n\t\tfor (var id in this._blockLookup) {\n\t\t\tvar str = id.split('-');\n\t\t\tvar x = ~~(parseInt(str[0], 10) * this._sizeMulti);\n\t\t\tvar y = ~~(parseInt(str[1], 10) * this._sizeMulti);\n\t\t\tvar idx = (x * this.heightInTiles) + y;\n\n\t\t\tthis.grid[idx] = 0;\n\t\t\tblock = this._blockLookup[id];\n\t\t\tthis._ctx.clearRect(block.position.x-25, block.position.y-25, this.tileSize, this.tileSize);\n\n\t\t\tthis._blockCache.add(block);\n\t\t\tblock.disable();\n\t\t\tdelete this._blockLookup[id];\n\t\t}\n\t},\n\n\ttoString: function() {\n\t\tvar str = '', x = 0, y = 0,\n\t\t\ti, v;\n\n\t\tfor (i = 0; i < this.numTiles; i++) {\n\t\t\tv = this.grid[~~((x * this.heightInTiles) + y)];\n\n\t\t\tif (v > 9 && v < 100) str += v + ',';\n\t\t\telse str += ' ' + v + ',';\n\n\t\t\tif (++x === this.widthInTiles) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t\tstr += '\\n';\n\t\t\t}\n\t\t}\n\t\tstr = str.substring(0, str.length-2); // get rid of the trailing comma because i'm ocd or something\n\t\treturn str;\n\t}\n};\n","/**\n * Optimized 2D general-purpose vector class with fairly complete functionality.\n */\nmh.Vec2 = function(x, y) {\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n};\n\nmh.Vec2.draw = function(ctx, v1, v2, drawingColor, camOffsetX, camOffsetY) {\n\tcamOffsetX = camOffsetX || 0;\n\tcamOffsetY = camOffsetY || 0;\n\tctx.strokeStyle = drawingColor ? drawingColor : 'rgb(250, 10, 10)';\n\tctx.beginPath();\n\tctx.moveTo(v1.x + camOffsetX, v1.y + camOffsetY);\n\tctx.lineTo(v2.x + camOffsetX, v2.y + camOffsetY);\n\tctx.stroke();\n};\n\nmh.Vec2.prototype = {\n\tconstructor: mh.Vec2,\n\n\t/*\n\t * Sets the length which will change x and y, but not the angle.\n\t */\n\tsetLength: function(value) {\n\t\tvar oldLength = this.getLength();\n\t\tif (oldLength !== 0 && value !== oldLength) {\n\t\t\tthis.multiplyScalar(value / oldLength);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetLength: function() {\n\t\treturn Math.sqrt((this.x * this.x) + (this.y * this.y));\n\t},\n\n\tgetLengthSq: function() {\n\t\treturn (this.x * this.x) + (this.y * this.y);\n\t},\n\n\tsetAngle: function(value) {\n\t\tvar len = this.getAngle();\n\t\tthis.x = Math.cos(value) * len;\n\t\tthis.y = Math.sin(value) * len;\n\t\treturn this;\n\t},\n\n\tgetAngle: function() {\n\t\treturn Math.atan2(this.y, this.x);\n\t},\n\n\trotateBy: function(theta) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar cos = Math.cos(theta), sin = Math.sin(theta);\n\t\tthis.x = x * cos - y * sin;\n\t\tthis.y = x * sin + y * cos;\n\t\treturn this;\n\t},\n\n\tadd: function(v) {\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\treturn this;\n\t},\n\n\taddScalar: function(s) {\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\treturn this;\n\t},\n\n\tsubtract: function(v) {\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\treturn this;\n\t},\n\n\tsubtractScalar: function(s) {\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\treturn this;\n\t},\n\n\tmultiply: function(v) {\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\treturn this;\n\t},\n\n\tmultiplyScalar: function(s) {\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\t\treturn this;\n\t},\n\n\tdivide: function(v) {\n\t\tif (v.x === 0 || v.y === 0) return this;\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\treturn this;\n\t},\n\n\tdivideScalar: function(s) {\n\t\tif (s === 0) return this;\n\t\tthis.x /= s;\n\t\tthis.y /= s;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Calculate the perpendicular vector (normal).\n\t */\n\tperp: function() {\n\t\tvar nx = -this.y;\n\t\tthis.y = this.x;\n\t\tthis.x = nx;\n\t\treturn this;\n\t},\n\n\tnegate: function() {\n\t\tthis.x = -this.x;\n\t\tthis.y = -this.y;\n\t\treturn this;\n\t},\n\n\t/**\n\t * This function assumes min < max, if this assumption isn't true it will not operate correctly.\n\t */\n\tclamp: function(min, max) {\n\t\tif (this.x < min.x) {\n\t\t\tthis.x = min.x;\n\t\t}\n\t\telse if (this.x > max.x) {\n\t\t\tthis.x = max.x;\n\t\t}\n\t\tif (this.y < min.y) {\n\t\t\tthis.y = min.y;\n\t\t}\n\t\telse if (this.y > max.y) {\n\t\t\tthis.y = max.y;\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Calculate a vector dot product.\n\t * @param {Vector2D} v A vector\n\t * @return {Number} The dot product\n\t */\n\tdotProduct: function(v) {\n\t\treturn (this.x * v.x + this.y * v.y);\n\t},\n\n\t/**\n\t * Calculate the cross product of this and another vector.\n\t * @param {Vector2D} v A vector\n\t * @return {Number} The cross product\n\t */\n\tcrossProd: function(v) {\n\t\treturn this.x * v.y - this.y * v.x;\n\t},\n\n\ttruncate: function(max) {\n\t\tvar l = this.getLength();\n\t\tif (l === 0 || l < max) return this;\n\t\tthis.x /= l;\n\t\tthis.y /= l;\n\t\tthis.multiplyScalar(max);\n\t\treturn this;\n\t},\n\n\tangleTo: function(v) {\n\t\tvar dx = this.x - v.x,\n\t\t\tdy = this.y - v.y;\n\t\treturn Math.atan2(dy, dx);\n\t},\n\n\tdistanceTo: function(v) {\n\t\tvar dx = this.x - v.x,\n\t\t\tdy = this.y - v.y;\n\t\treturn Math.sqrt((dx * dx) + (dy * dy));\n\t},\n\n\tdistanceToSquared: function(v) {\n\t\tvar dx = this.x - v.x,\n\t\t\tdy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\t},\n\n\tlerp: function(v, alpha) {\n\t\tthis.x += (v.x - this.x) * alpha;\n\t\tthis.y += (v.y - this.y) * alpha;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Normalize the vector\n\t * @return {Vector2D}\n\t */\n\tnormalize: function() {\n\t\tvar length = this.getLength();\n\t\tif (length === 0) return this;\n\t\tthis.x /= length;\n\t\tthis.y /= length;\n\t\treturn this;\n\t},\n\n\tset: function(x, y) {\n\t\tx = x ? x : 0;\n\t\ty = y ? y : 0;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tequals: function(v) {\n\t\tif (this.x === v.x && this.y === v.y) return true;\n\t\treturn false;\n\t},\n\n\t/**\n\t * Copy from given Vector.\n\t */\n\tcopy: function(v) {\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Return a new Vector object using this as a start.\n\t */\n\tclone: function() {\n\t\treturn new mh.Vec2(this.x, this.y);\n\t},\n\n\t/**\n\t * Visualize this vector.\n\t * @param {type} context \t\t\tHTML canvas 2D context to draw to.\n\t * @param {type} [startX] \t\t\tX offset to draw from.\n\t * @param {type} [startY] \t\t\tY offset to draw from.\n\t * @param {type} [drawingColor] \tCSS-compatible color to use.\n\t */\n\tdraw: function(ctx, startX, startY, drawingColor) {\n\t\tstartX = startX ? startX : 0;\n\t\tstartY = startY ? startY : 0;\n\t\tdrawingColor = drawingColor ? drawingColor : 'rgb(0, 250, 0)';\n\n\t\tctx.strokeStyle = drawingColor;\n\t\tctx.beginPath();\n\t\tctx.moveTo(startX, startY);\n\t\tctx.lineTo(this.x, this.y);\n\t\tctx.stroke();\n\t},\n\n\ttoString: function() {\n\t\treturn '['+this.x+', '+this.y+']';\n\t}\n};\n","/*\n\tThis is a flow grid (or vector grid) which is a combination of a grid that's generated using the wavefront algorithm, which is then used to build a grid of vectors that literally point to a goal. This provides directions for any entity to the goal point quickly. It is best used in situations where a LOT of entities share a goal, and even better when those entities use steering behaviors, making for a very fluid, natural motion path.\n\n\tFlexibility can be added by temporarily \"disrupting\" the grid with other fields emitted by dynamics obstacles. They would change the vector grid under them (not the grid) and have it return to normal as they move away.\n\n\tOptimization is needed. There should be sectors of the grid (or just one larger grid holding multiple FlowGrid instances) that only get rebuilt when needed. This might require another pathfinder like A* in order to determine which sectors need updating, to prevent the wave from propagating outside the needed bounds.\n\n\tA good place to improve on this is potential fields: http://aigamedev.com/open/tutorials/potential-fields/\n\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n\t@source http://gamedev.tutsplus.com/tutorials/implementation/goal-based-vector-field-pathfinding/\n*/\nmh.FlowGrid = function(cellSize, width, height) {\n\tthis.cellPixelSize = cellSize;\n\n\tthis.widthInCells = Math.floor(width / cellSize) + 1;\n\tthis.heightInCells = Math.floor(height / cellSize) + 1;\n\n\tthis.numCells = this.widthInCells * this.heightInCells;\n\n\tthis.grid = [];\n\n\tthis.goal = new mh.Vec2();\n\tthis.goalPixels = new mh.Vec2();\n\n\tthis._openList = new mh.LinkedList();\n\tthis._sizeMulti = 1 / this.cellPixelSize;\n\n\tvar i, j;\n\tfor (i = 0; i < this.widthInCells; i++) {\n\t\tthis.grid[i] = [];\n\t\tfor (j = 0; j < this.heightInCells; j++) {\n\t\t\tthis.grid[i][j] = new mh.FlowGridNode(i, j);\n\t\t}\n\t}\n\n\tmh.kai.flow = this;\n\n\tconsole.log('[FlowGrid] '+this.widthInCells+'x'+this.heightInCells);\n};\n\nmh.FlowGrid.prototype = {\n\t/**\n\t * Coordinates are in world space (pixels).\n\t */\n\tsetGoal: function(endPixelX, endPixelY) {\n\t\tvar endX = ~~(endPixelX * this._sizeMulti);\n\t\tvar endY = ~~(endPixelY * this._sizeMulti);\n\n\t\tif (endX < 0 || endY < 0 || endX >= this.widthInCells || endY >= this.heightInCells) {\n\t\t\tthrow new Error('[FlowGrid.build] Out of bounds');\n\t\t}\n\n\t\tif (this.goal.x === endX && this.goal.y === endY) return false;\n\n\t\tthis.goal.x = endX;\n\t\tthis.goal.y = endY;\n\t\tthis.goalPixels.activate(endPixelX, endPixelY);\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Runs a breadth-first search on the heatmap, stores how many steps it took to get to each tile\n\t * along the way. Then calculates the movement vectors.\n\t */\n\tbuild: function() {\n\t\tvar i, j, current, node, neighbor,\n\t\t\tv, a, b;\n\n\t\tfor (i = 0; i < this.widthInCells; i++) {\n\t\t\tfor (j = 0; j < this.heightInCells; j++) {\n\t\t\t\tthis.grid[i][j].open = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._openList.clear();\n\n\t\tnode = this.grid[this.goal.x][this.goal.y];\n\t\tnode.cost = 0;\n\n\t\tthis._openList.add(node);\n\n\t\t// front the wave. set fire to the brush. etc.\n\t\twhile (this._openList.length) {\n\t\t\tnode = this._openList.shift();\n\t\t\tnode.open = false;\n\n\t\t\tcurrent = this.grid[node.gridX][node.gridY];\n\n\t\t\t// left\n\t\t\tneighbor = node.gridX-1 >= 0 ? this.grid[node.gridX-1][node.gridY] : null;\n\t\t\tif (neighbor && neighbor.open && neighbor.passable) {\n\t\t\t\tneighbor.cost = current.cost + 1;\n\t\t\t\tneighbor.open = false; // we must set false now, in case a different neighbor gets this as neighbor\n\t\t\t\tthis._openList.add(neighbor);\n\t\t\t}\n\t\t\t// right\n\t\t\tneighbor = this.grid[node.gridX+1] ? this.grid[node.gridX+1][node.gridY] : null;\n\t\t\tif (neighbor && neighbor.open && neighbor.passable) {\n\t\t\t\tneighbor.cost = current.cost + 1;\n\t\t\t\tneighbor.open = false;\n\t\t\t\tthis._openList.add(neighbor);\n\t\t\t}\n\t\t\t// up\n\t\t\tneighbor = this.grid[node.gridX][node.gridY-1] || null;\n\t\t\tif (neighbor && neighbor.open && neighbor.passable) {\n\t\t\t\tneighbor.cost = current.cost + 1;\n\t\t\t\tneighbor.open = false;\n\t\t\t\tthis._openList.add(neighbor);\n\t\t\t}\n\t\t\t// down\n\t\t\tneighbor = this.grid[node.gridX][node.gridY+1] || null;\n\t\t\tif (neighbor && neighbor.open && neighbor.passable) {\n\t\t\t\tneighbor.cost = current.cost + 1;\n\t\t\t\tneighbor.open = false;\n\t\t\t\tthis._openList.add(neighbor);\n\t\t\t}\n\t\t\t// i++; // DEBUG\n\t\t}\n\n\t\t// recalculate the vector field\n\t\tfor (i = 0; i < this.widthInCells; i++) {\n\t\t\tfor (j = 0; j < this.heightInCells; j++) {\n\t\t\t\tv = this.grid[i][j];\n\n\t\t\t\ta = i-1 >= 0 && this.grid[i-1][j].passable ? this.grid[i-1][j].cost : v.cost;\n\t\t\t\tb = i+1 < this.widthInCells && this.grid[i+1][j].passable ? this.grid[i+1][j].cost : v.cost;\n\t\t\t\tv.x = a - b;\n\n\t\t\t\ta = j-1 >= 0 && this.grid[i][j-1].passable ? this.grid[i][j-1].cost : v.cost;\n\t\t\t\tb = j+1 < this.heightInCells && this.grid[i][j+1].passable ? this.grid[i][j+1].cost : v.cost;\n\t\t\t\tv.y = a - b;\n\t\t\t}\n\t\t}\n\t\t// TODO: normalize values\n\n\t\t// console.log('[FlowGrid.regenHeatmap] Completed in '+i+' iterations:');\n\t\t// console.log(this.toString());\n\t},\n\n\tdraw: function(ctx) {\n\t\tvar i, j, v, vx, vy;\n\t\tctx.lineWidth = 1;\n\t\tfor (i = 0; i < this.widthInCells; i++) {\n\t\t\tfor (j = 0; j < this.heightInCells; j++) {\n\t\t\t\tctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';\n\t\t\t\tctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n\t\t\t\tv = this.grid[i][j];\n\t\t\t\tif (!v.passable) continue;\n\n\t\t\t\tvx = (i*this.cellPixelSize)+(this.cellPixelSize*0.5);\n\t\t\t\tvy = (j*this.cellPixelSize)+(this.cellPixelSize*0.5);\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(vx, vy, 3, 0, mh.util.TAU, false);\n\t\t\t\tctx.fill();\n\t\t\t\tctx.moveTo(vx, vy);\n\t\t\t\tctx.lineTo(vx+(v.x*11), vy+(v.y*11));\n\t\t\t\tctx.stroke();\n\n\t\t\t\t// ctx.strokeStyle = 'rgba(120, 0, 0, 0.5)';\n\t\t\t\t// ctx.strokeRect(i*this.cellPixelSize, j*this.cellPixelSize, this.cellPixelSize, this.cellPixelSize);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Given the pixel coordinates, return the Vec2 associated with that position.\n\t */\n\tgetVectorAt: function(pos) {\n\t\tvar x = ~~(pos.x * this._sizeMulti);\n\t\tvar y = ~~(pos.y * this._sizeMulti);\n\t\tif (this.grid[x] && this.grid[x][y]) {\n\t\t\treturn this.grid[x][y];\n\t\t}\n\t\treturn null;\n\t},\n\n\t/**\n\t * Flips the flow switch at the provided pixel coordinates, so it will either become passable, or not.\n\t */\n\tsetBlockAt: function(x, y) {\n\t\tx = ~~(x * this._sizeMulti);\n\t\ty = ~~(y * this._sizeMulti);\n\t\tthis.grid[x][y].passable = !this.grid[x][y].passable;\n\t\tthis.grid[x][y].cost = -1;\n\n\t\tthis.build();\n\n\t\treturn !this.grid[x][y].passable;\n\t},\n\n\tclear: function() {\n\t\tvar i, j, v;\n\t\tfor (i = 0; i < this.widthInCells; i++) {\n\t\t\tfor (j = 0; j < this.heightInCells; j++) {\n\t\t\t\tv = this.grid[i][j];\n\t\t\t\tv.passable = true;\n\t\t\t\tv.cost = -1;\n\t\t\t}\n\t\t}\n\t\tthis.build();\n\t},\n\n\ttoString: function() {\n\t\tvar str = '', x = 0, y = 0,\n\t\t\ti, v;\n\n\t\tfor (i = 0; i < this.numCells; i++) {\n\t\t\tv = this.grid[x][y].cost;\n\n\t\t\tif (v > 99) str += v + ',';\n\t\t\telse if (v > 9 && v < 100) str += ' ' + v + ',';\n\t\t\telse str += '  ' + v + ',';\n\n\t\t\tif (++x === this.widthInCells) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t\tstr += '\\n';\n\t\t\t}\n\t\t}\n\t\tstr = str.substring(0, str.length-2); // get rid of the trailing comma because i'm ocd or something\n\t\treturn str;\n\t},\n\n\tlog: function() {\n\t\tconsole.log(this.toString());\n\t}\n};\n\nmh.FlowGridNode = function(gx, gy) {\n\t// velocity\n\tthis.x = 0;\n\tthis.y = 0;\n\n\tthis.gridX = gx;\n\tthis.gridY = gy;\n\n\t// heat value\n\tthis.cost = 0;\n\tthis.open = true;\n\tthis.passable = true;\n\n\tthis.uniqueID = Date.now() + '' + Math.floor(Math.random()*1000);\n};\n","/*\n\tA basic particle emitter: point and area emission, and a few dynamic force types.\n\tDoes not require an entity.\n\tBased on https://github.com/city41/particle.js\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh.Emitter = function(entity, settings) {\n\tsettings = settings || {};\n\tmh.Base.call(this);\n\n\t// adjustable properties available to override in settings\n\tthis.width = 10; // setting a nice default\n\tthis.height = 10;\n\tthis.container = mh.mh.kai.stage; // puts particles on top of everything\n\tthis.blend = false;\n\n\tthis.emitType = mh.Emitter.EmitType.Point;\n\tthis.emitDuration = -1; // how long to emit for, in seconds, or -1 for forever\n\tthis.emitAngle = 0; // angle at which particles are emitted only in radians\n\tthis.emitAngleVar = mh.util.TAU; // \"spread\" of emission based around emitAngle in radians; default is full circle\n\tthis.emitSpeed = 10;\n\tthis.emitSpeedVar = 0;\n\tthis.emitRate = 30; // how many per second\n\n\tthis.particleDuration = 1; // in seconds\n\tthis.particleDurationVar = 0;\n\tthis.particleScaleInit = 1; // 0 - 1\n\tthis.particleScaleVar = 0; // 0 - 1\n\t// this.particleScaleAccel = 1;\n\n\tthis.particleAlphaInit = 1; // 0 - 1\n\tthis.particleAlphaAccel = -2; // how fast to fade in (positive) or out (negative)\n\tthis.particleAlphaAccelDelay = 0.5; // seconds to wait before applying alpha accel\n\n\tthis.particleRotationAccel = 0; // particle sprite spin speed\n\tthis.particleRotationAccelVar = 0.2; // randomize starting particle sprite rotation speed\n\n\tthis.particleRadialAccel = 0;\n\tthis.particleRadialAccelVar = 0;\n\n\tthis.particleTangentialAccel = 0;\n\tthis.particleTangentialAccelVar = 0;\n\n\tthis.particleGravity = null;\n\n\tmh.util.overwrite(this, settings);\n\n\tthis.particleGravity = this.particleGravity || {x: 0, y: 0};\n\n\t// public\n\tthis.entity = entity || null; // avoiding undefined\n\tthis.duration = 0;\n\tthis.position = new mh.Vec2(); // get rid of Pixi's Point in favor of Vec2\n\tif (!this.uri) {\n\t\tthrow new Error('[Emitter] You must pass in an image uri through the settings parameter');\n\t}\n\tthis.texture = PIXI.Texture.fromImage(settings.uri);\n\t// this.texture.frame = new PIXI.Rectangle(this.offsetX, this.offsetY, this.width, this.height);\n\n\t// base\n\tthis.uniqueID = mh.util.generateID();\n\tthis.active = false;\n\n\t// private\n\tthis._force = new mh.Vec2(); // aggregate force applied to each particle on update(), resets on each iteration, do not use\n\tthis._vec = new mh.Vec2(); // scratch Vec2 for update(), do not use\n\tthis._emitTimer = 0;\n\tthis._pool = new mh.DualPool(mh.Particle, this, 15);\n\tthis._emissionSum = 0;\n};\n\n// inherit from PIXI SpriteBatch\nmh.Emitter.prototype = Object.create(PIXI.SpriteBatch.prototype);\nmh.Emitter.prototype.constructor = mh.Emitter;\n\n// required statics for component system\nmh.Emitter.accessor = 'emitter'; // property name as it sits on an entity\nmh.Emitter.className = 'EMITTER'; // name of component on the definition list object\nmh.Emitter.priority = 50; // general position in the engine's component array; updated in ascending order\n\n\n/*-------------------------------------------------------------------------------\n\t\t\t\t\t\t\t\t\tCOMPONENT INTERFACE\n-------------------------------------------------------------------------------*/\n\nmh.Emitter.prototype.activate = function() {\n\tthis.active = true;\n\tthis.container.addChild(this);\n\tthis.visible = true;\n\tthis.duration = 0;\n\tthis._emissionSum = this.emitRate * mh.kai.elapsed;\n};\n\nmh.Emitter.prototype.disable = function() {\n\tthis.active = false;\n\tthis.container.removeChild(this);\n\tthis._pool.freeAll();\n};\n\nmh.Emitter.prototype.update = function() {\n\tvar i, p, o, l = this._pool.busy; // only loop through active particles\n\n\tthis.duration += mh.kai.elapsed;\n\tif (this.emitDuration === -1 || this.duration < this.emitDuration) {\n\t\t// we can still emit\n\t\tthis._emissionSum += this.emitRate * mh.kai.elapsed;\n\t\tif (this._emissionSum >= 1) {\n\t\t\ti = Math.floor(this._emissionSum);\n\t\t\tthis.emit(i);\n\t\t\tthis._emissionSum -= i;\n\t\t}\n\t}\n\telse {\n\t\t// we are done emitting but we need to wait until all particles finish\n\t\tif (this._pool.busy.length === 0) {\n\t\t\tthis.disable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\to = l.first;\n\twhile (o) {\n\t\tp = o.obj; // update our active particles\n\t\to = o.next;\n\n\t\tp.duration += mh.kai.elapsed;\n\t\tif (p.alpha < 0 || p.duration >= this.particleDuration) {\n\t\t\tp.visible = false; // no need to disable, it gets taken out of the busy list when recycled\n\t\t\tthis._pool.recycle(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (p.fadeDelay <= 0) {\n\t\t\tp.alpha += this.particleAlphaAccel * mh.kai.elapsed;\n\t\t}\n\t\telse {\n\t\t\tp.fadeDelay -= mh.kai.elapsed;\n\t\t}\n\n\t\tthis._vec.set(p.vx, p.vy); // normalized velocity\n\t\tthis._force.copy(this._vec); // velocity\n\n\t\tthis._force.multiplyScalar(p.radialAccel);\n\n\t\tthis._vec.normalize();\n\t\tthis._vec.perp();\n\t\tthis._vec.multiplyScalar(p.tangentialAccel);\n\t\t// sum acceleration forces and integrate\n\t\tp.vx += (this._force.x + this._vec.x + this.particleGravity.x) * mh.kai.elapsed;\n\t\tp.vy += (this._force.y + this._vec.y + this.particleGravity.y) * mh.kai.elapsed;\n\t\tp.position.x += p.vx * mh.kai.elapsed;\n\t\tp.position.y += p.vy * mh.kai.elapsed;\n\t\tp.rotation += p.rotationAccel * mh.kai.elapsed;\n\t}\n};\n\nmh.Emitter.prototype.dispose = function() {\n\tthis.removeChildren();\n\tthis.texture.destroy();\n\tthis._pool.dispose();\n\tthis._pool = null;\n\tthis.forces = null;\n};\n\n/*-------------------------------------------------------------------------------\n\t\t\t\t\t\t\t\t\tPUBLIC\n-------------------------------------------------------------------------------*/\n\nmh.Emitter.prototype.emit = function(amt) {\n\tvar Type = mh.Emitter.EmitType;\n\tvar a, i, ii, p;\n\t// positions are relative to emitter (Pixi handles child coordinates)\n\tfor (i = 0; i < amt; i++) {\n\t\tp = this._pool.get();\n\t\tp.activate();\n\t\tp.duration = mh.util.random(this.particleDurationVar);\n\t\tp.rotation = mh.util.random(this.particleRotationAccelVar * mh.util.TAU);\n\t\tii = this.particleScaleInit + mh.util.random(this.particleScaleVar);\n\t\tp.scale.set(ii, ii);\n\t\tp.alpha = this.particleAlphaInit;\n\t\tp.fadeDelay = this.particleAlphaAccelDelay;\n\t\tp.blendMode = this.blend ? PIXI.blendModes.ADD : PIXI.blendModes.NORMAL;\n\t\t// velocity\n\t\ta = this.emitAngle + mh.util.random(this.emitAngleVar);\n\t\tii = this.emitSpeed + mh.util.random(this.emitSpeedVar);\n\t\tp.vx = Math.cos(a) * ii;\n\t\tp.vy = -Math.sin(a) * ii;\n\t\t// forces\n\t\tp.radialAccel = this.particleRadialAccel + mh.util.random(this.particleRadialAccelVar);\n\t\tp.tangentialAccel = this.particleTangentialAccel + mh.util.random(this.particleTangentialAccelVar);\n\t\tp.rotationAccel = this.particleRotationAccel + mh.util.random(this.particleRotationAccelVar);\n\t\t// position\n\t\tswitch (this.emitType) {\n\t\t\tcase Type.Rect:\n\t\t\t\tp.position.x = mh.util.randomInt(this._width);\n\t\t\t\tp.position.y = mh.util.randomInt(this._height);\n\t\t\t\tbreak;\n\t\t\tcase Type.Circle:\n\t\t\t\ta = Math.random() * mh.util.TAU;\n\t\t\t\tii = Math.random();\n\t\t\t\tp.position.x = ii * this._width * Math.cos(a);\n\t\t\t\tp.position.y = ii * this._height * Math.sin(a);\n\t\t\t\tbreak;\n\t\t\tcase Type.CircleUniform:\n\t\t\t\ta = Math.random() * mh.util.TAU;\n\t\t\t\tii = Math.sqrt(Math.random());\n\t\t\t\tp.position.x = ii * this._width * Math.cos(a);\n\t\t\t\tp.position.y = ii * this._height * Math.sin(a);\n\t\t\t\tbreak;\n\t\t\tcase Type.Ring:\n\t\t\t\ta = mh.util.random(mh.util.TAU);\n\t\t\t\tp.position.x = Math.cos(a) * this._width;\n\t\t\t\tp.position.y = Math.sin(a) * this._height;\n\t\t\t\tbreak;\n\t\t\tdefault: // Point\n\t\t\t\tp.position.x = 0;\n\t\t\t\tp.position.y = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\n/*-------------------------------------------------------------------------------\n\t\t\t\t\t\t\t\t\tSTATIC\n-------------------------------------------------------------------------------*/\n\nmh.Emitter.EmitType = {\n\tPoint: 0,\n\tRect: 2,\n\tCircle: 4,\n\tCircleUniform: 5,\n\tRing: 6\n};\n\n/*-------------------------------------------------------------------------------\n\t\t\t\t\t\t\t\t\tPARTICLE\n-------------------------------------------------------------------------------*/\n\n/*\n\tThe Emitter will instantiate these as necessary, so you only need to mess with the Emitter and it will efficiently apply it to its children.\n*/\nmh.Particle = function(parent) {\n\tPIXI.Sprite.call(this, parent.texture);\n\tthis.uniqueID = mh.util.generateID();\n\n\tparent.addChildAt(this, 0);\n\tthis.anchor.set(0.5, 0.5);\n\t// TODO: frame either the whole sprite or if its width is greater than its height, choose random frame\n\n\tthis.active = false;\n\tthis.visible = false;\n\tthis.duration = 0;\n\tthis.fadeDelay = 0;\n\tthis.vx = 0;\n\tthis.vy = 0;\n\tthis.radialAccel = 0;\n\tthis.tangentialAccel = 0;\n\tthis.rotationAccel = 0;\n};\n\n// inherit from PIXI Sprite\nmh.Particle.prototype = Object.create(PIXI.Sprite.prototype);\nmh.Particle.prototype.constructor = mh.Particle;\n\nmh.Particle.prototype.activate = function() {\n\t// many of these are overwritten by the emitter when spawned\n\tthis.active = true;\n\tthis.visible = true;\n\tthis.alpha = 1;\n\tthis.duration = 0;\n\tthis.rotation = 0;\n\tthis.vx = 0;\n\tthis.vy = 0;\n\tthis.radialAccel = 0;\n\tthis.tangentialAccel = 0;\n\tthis.rotationAccel = 0;\n};\n\nmh.Particle.prototype.disable = function() {\n\tthis.active = false;\n\tthis.visible = false;\n};\n","/*\n\t\"Boid\" behavior algorithms for more natural entity movement.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh.steering = {\n\t// cache of objects for reuse; there are a set for each function so they don't get overwritten\n\t_sumForce: new mh.Vec2(),\n\t_desiredVec: new mh.Vec2(),\n\t_scratchVec: new mh.Vec2(),\n\n\t_wanderVec: new mh.Vec2(),\n\t_seperationForce: new mh.Vec2(),\n\t_cohereForce: new mh.Vec2(),\n\t_alignForce: new mh.Vec2(),\n\t_wanderAngle: 0,\n\n\tseek: function(agent, dest, slowingRadius) {\n\t\tvar distance = agent.position.distanceTo(dest);\n\t\tslowingRadius = slowingRadius || 0;\n\n\t\tif (distance < 7) {\n\t\t\t// friction should bring the agent to a full stop\n\t\t\tagent.velocity.multiplyScalar(0.9);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._desiredVec.copy(dest).subtract(agent.position);\n\t\tthis._desiredVec.normalize();\n\n\t\tif (distance < slowingRadius) {\n\t\t\tthis._desiredVec.multiplyScalar(agent.maxForce * (distance / slowingRadius));\n\t\t\tagent.velocity.multiplyScalar(0.9); // apply friction to fight velocity (ie brake)\n\t\t}\n\t\telse {\n\t\t\tthis._desiredVec.multiplyScalar(agent.maxForce);\n\t\t}\n\n\t\tagent.steeringForce.add(this._desiredVec);\n\t},\n\n\tflee: function(agent, dest) {\n\t\tthis._desiredVec.copy(agent.position).subtract(dest);\n\t\tthis._desiredVec.normalize().multiplyScalar(agent.maxForce);\n\n\t\tagent.steeringForce.add(this._desiredVec);\n\t},\n\n\talign: function(agent, flock) {\n\t\tvar a, distance, neighboursCount = 0;\n\t\tvar node = flock.first;\n\t\tthis._alignForce.x = 0;\n\t\tthis._alignForce.y = 0;\n\n\t\t// for each of our neighbors (including self)...\n\t\twhile (node) {\n\t\t\ta = node.obj.entity.boid;\n\t\t\tif (a.groupID !== agent.groupID) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdistance = agent.position.distanceTo(a.position);\n\t\t\t// ...that are within the max distance and are moving...\n\t\t\tif (distance < agent.maxCohesion && a.velocity.getLength() > 0) {\n\t\t\t\t// ...sum up our headings\n\t\t\t\tthis._scratchVec.copy(a.velocity);\n\t\t\t\tthis._scratchVec.normalize();\n\t\t\t\tthis._alignForce.add(this._scratchVec);\n\t\t\t\t// also check if they're where we want to be and call it good\n\t\t\t\tif (a._arrived) agent._arrived = true;\n\t\t\t\tneighboursCount++;\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\n\t\tif (neighboursCount === 0) {\n\t\t\treturn this._alignForce; // zero\n\t\t}\n\n\t\t// divide to get the average heading\n\t\tthis._alignForce.divideScalar(neighboursCount);\n\t\tthis._alignForce.multiplyScalar(agent.maxForce);\n\n\t\treturn this._alignForce;\n\t},\n\n\tcohere: function(agent, flock) {\n\t\tvar a, distance,\n\t\t\tneighboursCount = 0,\n\t\t\tnode = flock.first;\n\n\t\tthis._sumForce.x = 0;\n\t\tthis._sumForce.y = 0;\n\n\t\twhile (node) {\n\t\t\ta = node.obj.entity.boid;\n\t\t\tif (a !== agent && a.groupID === agent.groupID) {\n\t\t\t\tdistance = agent.position.distanceTo(a.position);\n\t\t\t\tif (distance < agent.maxCohesion) {\n\t\t\t\t\t// sum up the position of our neighbors\n\t\t\t\t\tthis._sumForce.add(a.position);\n\t\t\t\t\tif (a._arrived) agent._arrived = true;\n\t\t\t\t\tneighboursCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\n\t\tif (neighboursCount === 0) {\n\t\t\tthis._cohereForce.x = 0;\n\t\t\tthis._cohereForce.y = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// get the average position of ourself and our neighbors\n\t\tthis._sumForce.divideScalar(neighboursCount);\n\n\t\t// seek that position\n\t\tthis._cohereForce.copy(this._sumForce).subtract(agent.position);\n\t\tthis._cohereForce.normalize().multiplyScalar(agent.maxForce);\n\n\t\treturn this._cohereForce;\n\t},\n\n\tseparate: function(agent, flock) {\n\t\tvar neighboursCount = 0;\n\t\tvar node = flock.first;\n\n\t\tthis._seperationForce.x = 0;\n\t\tthis._seperationForce.y = 0;\n\n\t\twhile (node) {\n\t\t\tvar a = node.obj.entity.boid;\n\t\t\tif (a !== agent) {\n\t\t\t\tvar distance = agent.position.distanceTo(a.position);\n\t\t\t\tif (distance < agent.minSeparation && distance > 0) {\n\t\t\t\t\t// vector to other agent\n\t\t\t\t\tthis._scratchVec.copy(a.position).subtract(agent.position);\n\t\t\t\t\t// var length = this._scratchVec.normalize();\n\t\t\t\t\tvar length = this._scratchVec.getLength();\n\t\t\t\t\tvar r = agent.minSeparation + a.minSeparation;\n\n\t\t\t\t\tthis._scratchVec.multiplyScalar(1 - ((length - r) / (agent.minSeparation - r)));\n\t\t\t\t\tthis._seperationForce.x += this._scratchVec.x;\n\t\t\t\t\tthis._seperationForce.y += this._scratchVec.y;\n\n\t\t\t\t\tneighboursCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\n\t\tif (neighboursCount === 0) {\n\t\t\treturn this._seperationForce;\n\t\t}\n\n\t\tthis._seperationForce.multiplyScalar(agent.maxForce / neighboursCount);\n\n\t\treturn this._seperationForce;\n\t},\n\n\twander: function(agent) {\n\t\tthis._desiredVec.copy(agent.velocity);\n\t\tthis._desiredVec.normalize();\n\t\tthis._desiredVec.multiplyScalar(agent.targetDistance);\n\n\t\tthis._scratchVec.reset(0, -1);\n\t\tthis._scratchVec.multiplyScalar(agent.targetRadius);\n\t\tthis._scratchVec.setAngle(agent._wanderAngle);\n\n\t\tagent._wanderAngle += (Math.random() * agent.angleJitter) - (agent.angleJitter * 0.5);\n\n\t\tthis._desiredVec.add(this._scratchVec);\n\t\tagent.steeringForce.add(this._desiredVec);\n\t},\n\n\n\t/*-------------------------------------------------------------------------------\n\t\t\t\t\t\t\t\t\tCOMPOSITE BEHAVIORS\n\t-------------------------------------------------------------------------------*/\n\n\tflock: function(agent, flock) {\n\t\tthis.separate(agent, flock);\n\t\tthis.align(agent, flock);\n\t\tthis.cohere(agent, flock);\n\t\tthis._seperationForce.multiplyScalar(0.2);\n\t\tthis._alignForce.multiplyScalar(1.3);\n\t\tthis._cohereForce.multiplyScalar(0.6);\n\t\tagent.steeringForce.x += this._seperationForce.x + this._alignForce.x + this._cohereForce.x;\n\t\tagent.steeringForce.y += this._seperationForce.y + this._alignForce.y + this._cohereForce.y;\n\t},\n\n\tfollowPath: function(agent, path, repeat) {\n\t\tvar target = path[agent._currentPathNode];\n\n\t\tif (agent._arrived || agent.position.distanceTo(target) <= agent.pathArriveRadius) {\n\t\t\tagent._currentPathNode += agent._pathDir;\n\t\t\tagent._arrived = false;\n\n\t\t\tif (agent._currentPathNode >= path.length || agent._currentPathNode < 0) {\n\t\t\t\tif (repeat) {\n\t\t\t\t\tagent._pathDir *= -1;\n\t\t\t\t\tagent._currentPathNode += agent._pathDir;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tagent._currentPathNode = path.length - 1;\n\t\t\t\t\ttarget = path[agent._currentPathNode];\n\t\t\t\t\tagent._arrived = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.seek(agent, target, agent.slowingRadius);\n\t},\n\n\tpursue: function(agent, targetAgent) {\n\t\t// calculate future position of target\n\t\tthis._scratchVec.copy(targetAgent.position).add(targetAgent.velocity);\n\t\tthis._scratchVec.multiplyScalar(agent.distanceTo(targetAgent) / agent.maxForce);\n\t\t// and seek that instead\n\t\tthis.seek(agent, this._scratchVec);\n\t},\n\n\tevade: function(agent, pursuingAgent) {\n\t\tthis._scratchVec.copy(pursuingAgent.position).add(pursuingAgent.velocity);\n\t\tthis._scratchVec.multiplyScalar(agent.distanceTo(pursuingAgent) / agent.maxForce);\n\n\t\tthis.flee(agent, this._scratchVec);\n\t},\n\n\t/*followLeader: function(agent, leader, flock) {\n\t\tvar tv :Vector3D = leader.velocity.clone();\n\t\tvar force :Vector3D = new Vector3D();\n\n\t\ttv.normalize();\n\t\ttv.scaleBy(LEADER_BEHIND_DIST);\n\n\t\tahead = leader.position.clone().add(tv);\n\n\t\ttv.scaleBy(-1);\n\t\tbehind = leader.position.clone().add(tv);\n\n\t\tif (isOnLeaderSight(leader, ahead)) {\n\t\t\talpha = 0.4;\n\t\t\tforce = force.add(evade(leader));\n\t\t\tforce.scaleBy(1.8); // make evade force stronger...\n\t\t} else {\n\t\t\talpha = 1;\n\t\t}\n\n\t\tforce = force.add(arrive(behind, 50));\n\t\tforce = force.add(separation(agent, flock));\n\n\t\tagent.steeringForce.add(this._desiredVec);\n\t}*/\n};\n","/*\n\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh.VectorFieldState = function(entity) {\n\tthis.uniqueID = mh.util.generateID();\n\n\tthis.fieldID = -1; // flow field index (as it sits in the array)\n\tthis.reachedGoal = true;\n\n\tmh.kai.addComponent(entity, mh.Component.FLOCK, mh.Flock);\n\n\t// shared references\n\tvar _position = entity.position,\n\t\t_vecField = mh.kai.flow;\n\n\t// internal settings\n\t// always best to use a timer to spread out the processing for expensive ops, especially when the user won't notice it\n\tvar _pollTime = 12,\n\t\t_timer = Math.ceil(Math.random() * _pollTime);\n\n\n\tthis.update = function() {\n\t\tvar node;\n\t\t_timer--;\n\t\tif (_timer < 0 && !this.reachedGoal) {\n\t\t\t_timer = _pollTime;\n\n\t\t\tif (_position.distanceTo(mh.kai.flow.goalPixels) < 100) {\n\t\t\t\t// console.log('reached goal');\n\t\t\t\tthis.reachedGoal = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode = entity.flock.nearby.first;\n\t\t\t\twhile (node) {\n\t\t\t\t\tif (!node.obj.vecFieldState) {\n\t\t\t\t\t\tnode = node.next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node.obj.vecFieldState.reachedGoal) {\n\t\t\t\t\t\t// console.log('neighbor reached goal');\n\t\t\t\t\t\tthis.reachedGoal = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn _vecField.getVectorAt(_position, this.fieldID);\n\t};\n\n\tthis.destroy = function() {\n\t\t_vecField = null;\n\t\t_position = null;\n\t\tentity = null;\n\t};\n};\n","/*\n\tControls a group of Boids for optimal pathing.\n\thttp://www.gamasutra.com/view/feature/131721/implementing_coordinated_movement.php?print=1\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh.BoidGroup = function(settings) {\n\tsettings = settings || {};\n\tmh.Base.call(this);\n\n\t// these are values that achieve optimal behavioral effects--use as a starting point\n\tthis.maxForce = 9999999; // this gets overwritten by the slowest member of the group\n\t// arrive\n\tthis.slowingRadius = 70;\n\tthis.pathArriveRadius = 60;\n\tthis.groupID = this.uniqueID; // never modify the uniqueID, so copy it to something we can mess with\n\tthis.repeat = false;\n\t// wander?\n\t// this.angleJitter = 0.9;\n\t// this.targetDistance = 20;\n\t// this.targetRadius = 20;\n\n\t// attribute override\n\tmh.util.overwrite(this, settings);\n\n\tthis.members = new mh.LinkedList();\n\tthis.steeringForce = new mh.Vec2();\n\n\t// private properties\n\t// this._wanderAngle = 0;\n\tthis._currentPathNode = 0;\n\tthis._pathDir = 1;\n\tthis._arrived = true;\n\tthis._nodePool = new mh.DualPool(mh.Vec2, null, 5);\n\n\t// prerequisite components\n\tthis.position = new mh.Vec2(); // average position of all members\n\tthis.velocity = new mh.Vec2(); // magnitude and orientation of the group\n\tthis.path = [];\n\n\tmh.kai.addComponent(this, mh.Component.STACK_FSM);\n\n\tthis.onComplete = new mh.Signal();\n\n\tthis.stackFSM.stateChanged.add(this._stateChanged, this);\n};\n\n// constants for passing into boid Signals\nmh.BoidGroup.DETACHED = 0;\nmh.BoidGroup.ATTACHED = 1;\n\nmh.BoidGroup.prototype = {\n\tconstructor: mh.BoidGroup,\n\n\t/*___________________________________________________________________________\n\t\t\tPUBLIC\n\t*/\n\n\taddBoid: function(boid) {\n\t\tboid.groupID = this.groupID;\n\t\tthis.members.add(boid);\n\t\tif (boid.maxForce < this.maxForce) {\n\t\t\tthis.maxForce = boid.maxForce;\n\t\t}\n\t},\n\n\taddEntity: function(entity) {\n\t\tif (!entity.boid) {\n\t\t\tconsole.warn('[BoidGroup.addEntity] All entities added to BoidGroup must have boid components');\n\t\t\treturn;\n\t\t}\n\t\tthis.addBoid(entity.boid);\n\t},\n\n\taddEntities: function(list) {\n\t\tvar entity, node = list.first;\n\t\twhile (node) {\n\t\t\tentity = node.obj;\n\t\t\tif (!entity.boid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.addBoid(entity.boid);\n\t\t\tnode = node.next;\n\t\t}\n\t},\n\n\tremoveBoid: function(boid) {\n\t\tvar node;\n\t\tthis.members.remove(boid);\n\t\tthis.maxForce = 9999999;\n\n\t\tif (this.members.length === 0) {\n\t\t\tthis.disable();\n\t\t\tthis.onComplete.dispatch(this);\n\t\t\treturn;\n\t\t}\n\n\t\tnode = this.members.first;\n\t\twhile (node) {\n\t\t\tif (boid.maxForce < this.maxForce) {\n\t\t\t\tthis.maxForce = boid.maxForce;\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\t},\n\n\tremoveEntity: function(entity) {\n\t\tthis.removeBoid(entity.boid);\n\t},\n\n\tremoveAll: function() {\n\t\tthis.members.clear();\n\t\tthis.disable(); // no group to move, so we're done\n\t\tthis.onComplete.dispatch(this);\n\t},\n\n\taddWaypoint: function(x, y) {\n\t\tvar v = this._nodePool.get();\n\t\tv.x = x;\n\t\tv.y = y;\n\t\tthis.path.push(v);\n\n\t\tthis._arrived = false;\n\t\tthis.stackFSM.pushState(this.followPath, this);\n\t},\n\n\t// we usually get a full path from some pathfinding algorithm, so this will non-destructively\n\t// set the new path and kick us off properly\n\tsetPath: function(newPath) {\n\t\tvar i, v;\n\t\t// just in case our path was switched in medias res\n\t\tthis._nodePool.freeAll();\n\t\tthis.path.length = 0;\n\n\t\tfor (i = 0; i < newPath.length; i++) {\n\t\t\tv = newPath[i];\n\t\t\tthis.addWaypoint(v.x, v.y);\n\t\t}\n\n\t\tthis.stackFSM.pushState(this.followPath, this);\n\t},\n\n\t/*sendCommand: function(newState) {\n\t\tvar entity, node = this.members.first;\n\t\twhile (node) {\n\t\t\tentity = node.obj.entity;\n\t\t\tif (entity.stackFSM) {\n\t\t\t\tentity.stackFSM.stateChanged.dispatch(newState);\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\t},*/\n\n\tactivate: function(members) {\n\t\tvar a, node;\n\t\tif (this.active) return;\n\n\t\tthis.active = true;\n\t\tthis.stackFSM.activate();\n\n\t\tif (members) {\n\t\t\tthis.members.clear();\n\t\t\tthis.addEntities(members);\n\t\t}\n\n\t\tnode = this.members.first;\n\t\twhile (node) {\n\t\t\ta = node.obj;\n\t\t\tthis.position.add(a.position);\n\t\t\tnode = node.next;\n\t\t}\n\t\tthis.position.divideScalar(this.members.length);\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t\tthis.reset();\n\t\tthis.stackFSM.disable();\n\t},\n\n\treset: function() {\n\t\t// note: entities must be managed independently! this only handles the path of the group\n\t\tthis.velocity.x = 0;\n\t\tthis.velocity.y = 0;\n\t\tthis._nodePool.freeAll();\n\t\tthis.path.length = 0;\n\t\tthis._currentPathNode = 0;\n\t\tthis._pathDir = 1;\n\t\tthis._arrived = true;\n\t},\n\n\tdispose: function() {\n\t\tmh.kai.removeComponent(this, mh.Component.STACK_FSM);\n\t\tthis.members.dispose();\n\t\tthis.members = null;\n\t\tthis._nodePool.dispose();\n\t\tthis._nodePool = null;\n\n\t\tthis.steeringForce = null;\n\t\tthis.position = null;\n\t\tthis.velocity = null;\n\t\tthis.path = null;\n\t},\n\n\t/*___________________________________________________________________________\n\t\t\tBEHAVIORS: called every tick by StackFSM\n\t*/\n\n\tfollowPath: function followPath() {\n\t\tvar a, node = this.members.first;\n\n\t\tmh.Steering.followPath(this, this.path, this.repeat);\n\n\t\t// update group position and apply new force to each member\n\t\tthis.position.x = 0;\n\t\tthis.position.y = 0;\n\n\t\twhile (node) {\n\t\t\ta = node.obj;\n\t\t\tif (a.groupID !== this.groupID) {\n\t\t\t\t// the entity must have been taken away from us by something, like a short attention span\n\t\t\t\tthis.removeBoid(a);\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmh.Steering.flock(a, this.members);\n\n\t\t\tthis.position.add(a.position);\n\t\t\ta.velocity.add(this.steeringForce);\n\t\t\tnode = node.next;\n\t\t}\n\t\tthis.position.divideScalar(this.members.length);\n\n\t\tthis.steeringForce.x = 0;\n\t\tthis.steeringForce.y = 0;\n\n\t\tif (this._arrived) {\n\t\t\tthis.stackFSM.popState();\n\t\t}\n\t},\n\n\t/*___________________________________________________________________________\n\t\t\tPRIVATE: EVENTS\n\t*/\n\n\t_stateChanged: function(oldState, newState) {\n\t\tvar target, a, node = this.members.first;\n\n\t\tif (oldState === newState) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (newState) {\n\t\t\tcase 'followPath':\n\t\t\t\tthis.activate();\n\t\t\t\tthis._currentPathNode = 0;\n\t\t\t\tthis._pathDir = 1;\n\t\t\t\tthis._arrived = false;\n\t\t\t\ttarget = this.path[this._currentPathNode];\n\t\t\t\tthis.velocity.copy(target);\n\t\t\t\tthis.velocity.normalize().multiplyScalar(this.maxForce);\n\n\t\t\t\t// notify members\n\t\t\t\twhile (node) {\n\t\t\t\t\ta = node.obj;\n\t\t\t\t\ta.groupControl.dispatch(mh.BoidGroup.ATTACHED);\n\t\t\t\t\tnode = node.next;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// a state we don't have (ie idle), so we're done\n\t\t\t\tthis.disable();\n\n\t\t\t\t// notify members\n\t\t\t\twhile (node) {\n\t\t\t\t\ta = node.obj;\n\t\t\t\t\ta.groupControl.dispatch(mh.BoidGroup.DETACHED);\n\t\t\t\t\tnode = node.next;\n\t\t\t\t}\n\t\t\t\t// any anyone else\n\t\t\t\tthis.onComplete.dispatch(this);\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n","/*\n\tControls the acceleration of an entity and enables steering behaviors to be used.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh.Boid = function(entity, settings) {\n\tsettings = settings || {};\n\tmh.Base.call(this);\n\n\t// these are values that achieve optimal behavioral effects--use as a starting point\n\tthis.maxForce = 10;\n\t// arrive\n\tthis.slowingRadius = 50;\n\tthis.pathArriveRadius = 50;\n\t// follow leader\n\t// this.leaderBehindDist = 100;\n\t// this.leaderSightRadius = 300;\n\t// flocking--these defaults are for entities with a 50 pixel radius\n\tthis.groupID = 0;\n\tthis.flockRadius = 160; // distance where flocking (alignment) starts to happen\n\tthis.maxCohesion = 140; // radius within which cohesion rule is in effect\n\tthis.minSeparation = 70; // distance at which separation rule goes into effect\n\t// wander\n\tthis.angleJitter = 0.9;\n\tthis.targetDistance = 20;\n\tthis.targetRadius = 20;\n\n\t// attribute override\n\tmh.util.overwrite(this, settings);\n\n\tthis.entity = entity;\n\tthis.steeringForce = new mh.Vec2(mh.util.random(this.maxForce), mh.util.random(this.maxForce));\n\n\tthis.maxSpeed = this.entity.maxSpeed || this.maxForce;\n\tif (entity.body) {\n\t\tthis.maxSpeed = entity.body.maxSpeed;\n\t}\n\n\t// private properties\n\tthis._wanderAngle = 0;\n\t// this._prevAngle = 0;\n\tthis._currentPathNode = 0;\n\tthis._pathDir = 1;\n\tthis._arrived = false;\n\n\t// prerequisite components\n\tthis.position = mh.kai.expect(entity, 'position', mh.Vec2);\n\tthis.rotation = mh.kai.expect(entity, 'rotation', mh.Vec2);\n\tthis.velocity = mh.kai.expect(entity, 'velocity', mh.Vec2);\n\n\tthis.groupControl = new mh.Signal();\n};\n\n// required statics for component system\nmh.Boid.accessor = 'boid'; // property name as it sits on an entity\nmh.Boid.className = 'BOID'; // name of component on the component definition object\nmh.Boid.priority = 95; // just before the physics components (at 100) but otherwise dead last\nmh.Boid.post = false; // whether or not this component will have a postUpdate() called on it\n\nmh.Boid.prototype = {\n\tconstructor: mh.Boid,\n\n\tactivate: function() {\n\t\tthis.active = true;\n\t\tthis._currentPathNode = 0;\n\t\tthis._pathDir = 1;\n\t\tthis._arrived = false;\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t},\n\n\tupdate: function() {\n\t\t// steeringForce has been modified by Steering so cap it and apply\n\t\tthis.steeringForce.truncate(this.maxForce);\n\n\t\t// let physical mass affect movement\n\t\tthis.steeringForce.multiplyScalar(this.entity.body.invmass);\n\t\t// DebugDraw.vector(Kai.debugCtx, this.steeringForce, this.position);\n\n\t\tthis.velocity.x += this.steeringForce.x;\n\t\tthis.velocity.y += this.steeringForce.y;\n\n\t\t// adjust rotation to match the velocity vector--the view component will take care of the rest\n\t\tthis.rotation.x = this.velocity.x;\n\t\tthis.rotation.y = this.velocity.y;\n\n\t\t// reset for next time, so steering forces get applied in the updates of other components\n\t\tthis.steeringForce.x = 0;\n\t\tthis.steeringForce.y = 0;\n\t},\n\n\tdispose: function() {\n\t\tthis.groupControl.dispose();\n\t\tthis.groupControl = null;\n\t\tthis.entity = null;\n\t\tthis.steeringForce = null;\n\t\tthis.position = null;\n\t\tthis.rotation = null;\n\t\tthis.velocity = null;\n\t}\n};\n","/*\n\tAbstracts pixi sprite creation so it's compatible with our entity-component system.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh.PIXISprite = function(entity, settings) {\n\tsettings = settings || {};\n\tmh.Base.call(this);\n\n\tthis.textureUrl = 'img/square-outline-textured.png';\n\tthis.container = mh.kai.view;\n\n\tmh.util.overwrite(this, settings);\n\n\t// private properties\n\tthis.entity = entity;\n\tthis._display = null;\n\n\t// prerequisite components\n\tthis.position = entity.position;\n};\n\n// required statics for component system\nmh.PIXISprite.accessor = 'view'; // property name as it sits on an entity\nmh.PIXISprite.className = 'VIEW_SPRITE'; // name of component on the ComponenDef object\nmh.PIXISprite.priority = 10; // general position in the engine's component array; highest updated first\n\nmh.PIXISprite.prototype = {\n\tconstructor: mh.PIXISprite,\n\n\tactivate: function() {\n\t\tthis.active = true;\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t},\n\n\tupdate: function() {\n\n\t},\n\n\tdispose: function() {\n\t\tthis.disable();\n\n\t\t// null references\n\t\tthis.entity = null;\n\t\tthis.position = null;\n\t}\n};\n"],"sourceRoot":"/source/"}