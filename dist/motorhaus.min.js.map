{"version":3,"sources":["math/Vec2.js","core/LinkedList.js","core/Kai.js","core/Signal.js","core/CommTower.js","core/StateManager.js","utils/RequestAnimationFrame.js","utils/Loader.js","utils/Cache.js","components/input/MouseController.js","components/input/KeyboardController.js","core/Engine.js","utils/Tools.js","core/World.js","physics/PhysicsConstants.js","utils/DebugDraw.js","core/Base.js","components/physics/AABB2.js","components/physics/AABB3.js","components/physics/RadialCollider2.js","physics/Manifold.js","physics/Physics2.js","components/physics/CollisionGridScanner.js","components/Health.js","components/input/TwinStickMovement.js","components/Timer.js","components/GridTargeter.js","math/MathTools.js","components/ai/Boid.js","components/ai/StackFSM.js","components/VonComponents.js","physics/CollisionGrid.js","utils/DOMTools.js","utils/DualPool.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3HA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"motorhaus.min.js","sourcesContent":["var mh = {};\nmh['Vec2'] = function () {\n    var Vec2 = function (x, y) {\n        if (typeof x === 'undefined')\n            x = 0;\n        if (typeof y === 'undefined')\n            y = 0;\n        this.x = x;\n        this.y = y;\n    };\n    Vec2.prototype.setLength = function (value) {\n        var oldLength = this.getLength();\n        if (oldLength !== 0 && value !== oldLength) {\n            this.multiplyScalar(value / oldLength);\n        }\n        return this;\n    };\n    Vec2.prototype.getLength = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    };\n    Vec2.prototype.getLengthSq = function () {\n        return this.x * this.x + this.y * this.y;\n    };\n    Vec2.prototype.setAngle = function (value) {\n        var len = this.getAngle();\n        this.x = Math.cos(value) * len;\n        this.y = Math.sin(value) * len;\n        return this;\n    };\n    Vec2.prototype.getAngle = function () {\n        return Math.atan2(this.y, this.x);\n    };\n    Vec2.prototype.rotateBy = function (theta) {\n        var x = this.x, y = this.y;\n        var cos = Math.cos(theta), sin = Math.sin(theta);\n        this.x = x * cos - y * sin;\n        this.y = x * sin + y * cos;\n        return this;\n    };\n    Vec2.prototype.add = function (v) {\n        this.x += v.x;\n        this.y += v.y;\n        return this;\n    };\n    Vec2.prototype.addScalar = function (s) {\n        this.x += s;\n        this.y += s;\n        return this;\n    };\n    Vec2.prototype.subtract = function (v) {\n        this.x -= v.x;\n        this.y -= v.y;\n        return this;\n    };\n    Vec2.prototype.subtractScalar = function (s) {\n        this.x -= s;\n        this.y -= s;\n        return this;\n    };\n    Vec2.prototype.multiply = function (v) {\n        this.x *= v.x;\n        this.y *= v.y;\n        return this;\n    };\n    Vec2.prototype.multiplyScalar = function (s) {\n        this.x *= s;\n        this.y *= s;\n        return this;\n    };\n    Vec2.prototype.divide = function (v) {\n        if (v.x === 0 || v.y === 0)\n            return this;\n        this.x /= v.x;\n        this.y /= v.y;\n        return this;\n    };\n    Vec2.prototype.divideScalar = function (s) {\n        if (s === 0)\n            return this;\n        this.x /= s;\n        this.y /= s;\n        return this;\n    };\n    Vec2.prototype.perp = function () {\n        var nx = -this.y;\n        this.y = this.x;\n        this.x = nx;\n        return this;\n    };\n    Vec2.prototype.negate = function () {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    };\n    Vec2.prototype.clamp = function (min, max) {\n        if (this.x < min.x) {\n            this.x = min.x;\n        } else if (this.x > max.x) {\n            this.x = max.x;\n        }\n        if (this.y < min.y) {\n            this.y = min.y;\n        } else if (this.y > max.y) {\n            this.y = max.y;\n        }\n        return this;\n    };\n    Vec2.prototype.dotProduct = function (v) {\n        return this.x * v.x + this.y * v.y;\n    };\n    Vec2.prototype.crossProd = function (v) {\n        return this.x * v.y - this.y * v.x;\n    };\n    Vec2.prototype.truncate = function (max) {\n        var l = this.getLength();\n        if (l === 0 || l < max)\n            return this;\n        this.x /= l;\n        this.y /= l;\n        this.multiplyScalar(max);\n        return this;\n    };\n    Vec2.prototype.angleTo = function (v) {\n        var dx = this.x - v.x, dy = this.y - v.y;\n        return Math.atan2(dy, dx);\n    };\n    Vec2.prototype.distanceTo = function (v) {\n        var dx = this.x - v.x, dy = this.y - v.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    Vec2.prototype.distanceToSquared = function (v) {\n        var dx = this.x - v.x, dy = this.y - v.y;\n        return dx * dx + dy * dy;\n    };\n    Vec2.prototype.lerp = function (v, alpha) {\n        this.x += (v.x - this.x) * alpha;\n        this.y += (v.y - this.y) * alpha;\n        return this;\n    };\n    Vec2.prototype.normalize = function () {\n        var length = this.getLength();\n        if (length === 0)\n            return this;\n        this.x /= length;\n        this.y /= length;\n        return this;\n    };\n    Vec2.prototype.set = function (x, y) {\n        x = x ? x : 0;\n        y = y ? y : 0;\n        this.x = x;\n        this.y = y;\n        return this;\n    };\n    Vec2.prototype.equals = function (v) {\n        if (this.x === v.x && this.y === v.y)\n            return true;\n        return false;\n    };\n    Vec2.prototype.copy = function (v) {\n        this.x = v.x;\n        this.y = v.y;\n        return this;\n    };\n    Vec2.prototype.clone = function () {\n        return new Vec2(this.x, this.y);\n    };\n    Vec2.prototype.draw = function (ctx, startX, startY, drawingColor) {\n        startX = !!startX ? startX : 0;\n        startY = !!startY ? startY : 0;\n        drawingColor = !!drawingColor ? drawingColor : 'rgb(0, 250, 0)';\n        ctx.strokeStyle = drawingColor;\n        ctx.beginPath();\n        ctx.moveTo(startX, startY);\n        ctx.lineTo(this.x, this.y);\n        ctx.stroke();\n    };\n    Vec2.prototype.toString = function () {\n        return '[' + this.x + ', ' + this.y + ']';\n    };\n    Vec2.draw = function (ctx, v1, v2, drawingColor, camOffsetX, camOffsetY) {\n        camOffsetX = camOffsetX || 0;\n        camOffsetY = camOffsetY || 0;\n        ctx.strokeStyle = !!drawingColor ? drawingColor : 'rgb(250, 10, 10)';\n        ctx.beginPath();\n        ctx.moveTo(v1.x + camOffsetX, v1.y + camOffsetY);\n        ctx.lineTo(v2.x + camOffsetX, v2.y + camOffsetY);\n        ctx.stroke();\n    };\n    window.Vec2 = Vec2;\n    return Vec2;\n}();\n","/**\n * @source https://github.com/martinwells/gamecore.js\n * Hoisted to the global namespace for convenience.\n */\nmh['LinkedList'] = function () {\n    var LinkedListNode = function () {\n        this.obj = null;\n        this.next = null;\n        this.prev = null;\n        this.free = true;\n    };\n    window.LinkedListNode = LinkedListNode;\n    var LinkedList = function () {\n        this.first = null;\n        this.last = null;\n        this.length = 0;\n        this.objToNodeMap = {};\n        this.uniqueId = Date.now() + '' + Math.floor(Math.random() * 1000);\n        this.priority = 0;\n        this.getNode = function (obj) {\n            return this.objToNodeMap[obj.uniqueId];\n        };\n        this.addNode = function (obj) {\n            var node = new LinkedListNode();\n            node.obj = obj;\n            node.prev = null;\n            node.next = null;\n            node.free = false;\n            this.objToNodeMap[obj.uniqueId] = node;\n            return node;\n        };\n        this.swapObjects = function (node, newObj) {\n            this.objToNodeMap[node.obj.uniqueId] = null;\n            this.objToNodeMap[newObj.uniqueId] = node;\n            node.obj = newObj;\n        };\n        this.add = function (obj) {\n            var node = this.objToNodeMap[obj.uniqueId];\n            if (!node) {\n                node = this.addNode(obj);\n            } else {\n                if (node.free === false)\n                    return;\n                node.obj = obj;\n                node.free = false;\n                node.next = null;\n                node.prev = null;\n            }\n            if (!this.first) {\n                this.first = node;\n                this.last = node;\n                node.next = null;\n                node.prev = null;\n            } else {\n                if (this.last == null) {\n                    throw new Error('Hmm, no last in the list -- that shouldn\\'t happen here');\n                }\n                this.last.next = node;\n                node.prev = this.last;\n                this.last = node;\n                node.next = null;\n            }\n            this.length++;\n            if (this.showDebug)\n                this.dump('after add');\n        };\n        this.has = function (obj) {\n            return !!this.objToNodeMap[obj.uniqueId];\n        };\n        this.moveUp = function (obj) {\n            this.dump('before move up');\n            var c = this.getNode(obj);\n            if (!c)\n                throw 'Oops, trying to move an object that isn\\'t in the list';\n            if (c.prev == null)\n                return;\n            var b = c.prev;\n            var a = b.prev;\n            if (c == this.last)\n                this.last = b;\n            var oldCNext = c.next;\n            if (a)\n                a.next = c;\n            c.next = b;\n            c.prev = b.prev;\n            b.next = oldCNext;\n            b.prev = c;\n            if (this.first == b)\n                this.first = c;\n        };\n        this.moveDown = function (obj) {\n            var b = this.getNode(obj);\n            if (!b)\n                throw 'Oops, trying to move an object that isn\\'t in the list';\n            if (b.next == null)\n                return;\n            var c = b.next;\n            this.moveUp(c.obj);\n            if (this.last == c)\n                this.last = b;\n        };\n        this.sort = function (compare) {\n            var sortArray = [];\n            var i, l, node = this.first;\n            while (node) {\n                sortArray.push(node.object());\n                node = node.next();\n            }\n            this.clear();\n            sortArray.sort(compare);\n            l = sortArray.length;\n            for (i = 0; i < l; i++) {\n                this.add(sortArray[i]);\n            }\n        };\n        this.remove = function (obj) {\n            var node = this.getNode(obj);\n            if (node == null || node.free == true) {\n                return false;\n            }\n            if (node.prev != null)\n                node.prev.next = node.next;\n            if (node.next != null)\n                node.next.prev = node.prev;\n            if (node.prev == null)\n                this.first = node.next;\n            if (node.next == null)\n                this.last = node.prev;\n            node.free = true;\n            node.prev = null;\n            node.next = null;\n            this.length--;\n            return true;\n        };\n        this.shift = function () {\n            var node = this.first;\n            if (this.length === 0)\n                return null;\n            if (node.prev) {\n                node.prev.next = node.next;\n            }\n            if (node.next) {\n                node.next.prev = node.prev;\n            }\n            this.first = node.next;\n            if (!node.next)\n                this.last = null;\n            node.free = true;\n            node.prev = null;\n            node.next = null;\n            this.length--;\n            return node.obj;\n        };\n        this.pop = function () {\n            var node = this.last;\n            if (this.length === 0)\n                return null;\n            if (node.prev) {\n                node.prev.next = node.next;\n            }\n            if (node.next) {\n                node.next.prev = node.prev;\n            }\n            this.last = node.prev;\n            if (!node.prev)\n                this.first = null;\n            node.free = true;\n            node.prev = null;\n            node.next = null;\n            this.length--;\n            return node.obj;\n        };\n        this.concat = function (list) {\n            var node = list.first;\n            while (node) {\n                this.add(node.obj);\n                node = node.next;\n            }\n        };\n        this.clear = function () {\n            var next = this.first;\n            while (next) {\n                next.free = true;\n                next = next.next;\n            }\n            this.first = null;\n            this.length = 0;\n        };\n        this.dispose = function () {\n            var next = this.first;\n            while (next) {\n                next.obj = null;\n                next = next.next;\n            }\n            this.first = null;\n            this.objToNodeMap = null;\n        };\n        this.dump = function (msg) {\n            console.log('====================' + msg + '=====================');\n            var a = this.first;\n            while (a != null) {\n                console.log('{' + a.obj.toString() + '} previous=' + (a.prev ? a.prev.obj : 'NULL'));\n                a = a.next();\n            }\n            console.log('===================================');\n            console.log('Last: {' + (this.last ? this.last.obj : 'NULL') + '} ' + 'First: {' + (this.first ? this.first.obj : 'NULL') + '}');\n        };\n    };\n    window.LinkedList = LinkedList;\n    return LinkedList;\n}();\n","/*\n\tGlobal state resources object that also manages components. No idea why I called it 'Kai'.\n\tI consider this the most important part of the engine, since it makes the whole entity-component thing work.\n\t\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh['Kai'] = function (require, Vec2, LinkedList) {\n    return {\n        engine: null,\n        stage: null,\n        renderHook: null,\n        world: null,\n        mouse: null,\n        keys: null,\n        pads: null,\n        cache: null,\n        load: null,\n        debugCtx: null,\n        debugMessages: true,\n        components: [],\n        componentsSorted: [],\n        componentDefinitions: [],\n        numComponents: 0,\n        width: window.innerWidth,\n        height: window.innerHeight,\n        ready: false,\n        inputBlocked: true,\n        expect: function (entity, prop, Clazz) {\n            var i;\n            if (!entity[prop]) {\n                if (!Clazz) {\n                    for (i = 0; i < this.componentDefinitions.length; i++) {\n                        Clazz = this.componentDefinitions[i];\n                        if (Clazz.accessor === prop) {\n                            break;\n                        }\n                    }\n                    if (!Clazz) {\n                        throw new Error('[Kai.expect] The component \"' + prop + '\" does not exist. You might have forgotten to create a component list object (just like VonComponents.js), or forgot to add this component to that list.');\n                    }\n                    this.addComponent(entity, Clazz);\n                    if (this.debugMessages) {\n                        console.info('[Kai.expect] ' + prop.toUpperCase() + ' component was added to ' + entity.toString() + ' with default values');\n                    }\n                } else {\n                    entity[prop] = new Clazz();\n                }\n            }\n            return entity[prop];\n        },\n        registerComponents: function (factoryList) {\n            var i, k, def, list, len = factoryList.length, Factory, exportedComponents = {};\n            for (i = 0; i < len; i++) {\n                Factory = factoryList[i];\n                k = this.numComponents;\n                exportedComponents[Factory.className] = {\n                    accessor: Factory.accessor,\n                    proto: Factory,\n                    index: k,\n                    priority: Factory.priority\n                };\n                this.numComponents++;\n                if (!!this.components[k]) {\n                    continue;\n                }\n                list = new LinkedList();\n                list.priority = Factory.priority;\n                this.components[k] = list;\n                this.componentDefinitions[k] = exportedComponents[Factory.className];\n                this.componentsSorted[k] = list;\n                if (this.debugMessages) {\n                    console.info('[Kai] Registered ' + Factory.className);\n                }\n            }\n            function compare(a, b) {\n                return a.priority - b.priority;\n            }\n            this.componentsSorted.sort(compare);\n            return exportedComponents;\n        },\n        addComponent: function (entity, compDef, options, arr) {\n            var prop = compDef.accessor, compInstance = null;\n            options = options || null;\n            if (entity.hasOwnProperty(prop)) {\n                if (this.debugMessages) {\n                    console.warn('[Kai.addComponent] \"' + prop + '\" already exists on entity ' + entity.toString());\n                }\n                return;\n            }\n            compInstance = new compDef.proto(entity, options);\n            this.components[compDef.index].add(compInstance);\n            if (typeof arr === 'undefined') {\n                entity[prop] = compInstance;\n            } else {\n                arr.push(compInstance);\n            }\n        },\n        removeComponent: function (entity, compDef) {\n            var prop = compDef.accessor;\n            if (entity.hasOwnProperty(prop)) {\n                this.components[compDef.index].remove(entity[prop]);\n                entity[prop].dispose();\n                entity[prop] = null;\n            }\n        }\n    };\n}({}, mh['Vec2'], mh['LinkedList']);\n","mh['Signal'] = function () {\n    var SignalBinding = function (signal, listener, isOnce, listenerContext, priority) {\n        if (typeof priority === 'undefined') {\n            priority = 0;\n        }\n        this.active = true;\n        this.params = null;\n        this._listener = listener;\n        this._isOnce = isOnce;\n        this.context = listenerContext;\n        this._signal = signal;\n        this.priority = priority || 0;\n    };\n    SignalBinding.prototype.execute = function (paramsArr) {\n        var handlerReturn;\n        var params;\n        if (this.active && !!this._listener) {\n            params = this.params ? this.params.concat(paramsArr) : paramsArr;\n            handlerReturn = this._listener.apply(this.context, params);\n            if (this._isOnce) {\n                this.detach();\n            }\n        }\n        return handlerReturn;\n    };\n    SignalBinding.prototype.detach = function () {\n        return this.isBound() ? this._signal.remove(this._listener, this.context) : null;\n    };\n    SignalBinding.prototype.isBound = function () {\n        return !!this._signal && !!this._listener;\n    };\n    SignalBinding.prototype.isOnce = function () {\n        return this._isOnce;\n    };\n    SignalBinding.prototype.getListener = function () {\n        return this._listener;\n    };\n    SignalBinding.prototype.getSignal = function () {\n        return this._signal;\n    };\n    SignalBinding.prototype._destroy = function () {\n        delete this._signal;\n        delete this._listener;\n        delete this.context;\n    };\n    SignalBinding.prototype.toString = function () {\n        return '[SignalBinding isOnce:' + this._isOnce + ', isBound:' + this.isBound() + ', active:' + this.active + ']';\n    };\n    window.SignalBinding = SignalBinding;\n    var Signal = function () {\n        this._bindings = [];\n        this._prevParams = null;\n        this.memorize = false;\n        this._shouldPropagate = true;\n        this.active = true;\n    };\n    Signal.prototype.validateListener = function (listener, fnName) {\n        if (typeof listener !== 'function') {\n            throw new Error('listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));\n        }\n    };\n    Signal.prototype._registerListener = function (listener, isOnce, listenerContext, priority) {\n        var prevIndex = this._indexOfListener(listener, listenerContext);\n        var binding;\n        if (prevIndex !== -1) {\n            binding = this._bindings[prevIndex];\n            if (binding.isOnce() !== isOnce) {\n                throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');\n            }\n        } else {\n            binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);\n            this._addBinding(binding);\n        }\n        if (this.memorize && this._prevParams) {\n            binding.execute(this._prevParams);\n        }\n        return binding;\n    };\n    Signal.prototype._addBinding = function (binding) {\n        var n = this._bindings.length;\n        do {\n            --n;\n        } while (this._bindings[n] && binding.priority <= this._bindings[n].priority);\n        this._bindings.splice(n + 1, 0, binding);\n    };\n    Signal.prototype._indexOfListener = function (listener, context) {\n        var n = this._bindings.length;\n        var cur;\n        while (n--) {\n            cur = this._bindings[n];\n            if (cur.getListener() === listener && cur.context === context) {\n                return n;\n            }\n        }\n        return -1;\n    };\n    Signal.prototype.has = function (listener, context) {\n        if (typeof context === 'undefined') {\n            context = null;\n        }\n        return this._indexOfListener(listener, context) !== -1;\n    };\n    Signal.prototype.add = function (listener, listenerContext, priority) {\n        if (typeof listenerContext === 'undefined') {\n            listenerContext = null;\n        }\n        if (typeof priority === 'undefined') {\n            priority = 0;\n        }\n        this.validateListener(listener, 'add');\n        return this._registerListener(listener, false, listenerContext, priority);\n    };\n    Signal.prototype.addOnce = function (listener, listenerContext, priority) {\n        if (typeof listenerContext === 'undefined') {\n            listenerContext = null;\n        }\n        if (typeof priority === 'undefined') {\n            priority = 0;\n        }\n        this.validateListener(listener, 'addOnce');\n        return this._registerListener(listener, true, listenerContext, priority);\n    };\n    Signal.prototype.remove = function (listener, context) {\n        if (typeof context === 'undefined') {\n            context = null;\n        }\n        this.validateListener(listener, 'remove');\n        var i = this._indexOfListener(listener, context);\n        if (i !== -1) {\n            this._bindings[i]._destroy();\n            this._bindings.splice(i, 1);\n        }\n        return listener;\n    };\n    Signal.prototype.removeAll = function () {\n        var n = this._bindings.length;\n        while (n--) {\n            this._bindings[n]._destroy();\n        }\n        this._bindings.length = 0;\n    };\n    Signal.prototype.getNumListeners = function () {\n        return this._bindings.length;\n    };\n    Signal.prototype.halt = function () {\n        this._shouldPropagate = false;\n    };\n    Signal.prototype.dispatch = function () {\n        var paramsArr = [];\n        for (var _i = 0; _i < arguments.length - 0; _i++) {\n            paramsArr[_i] = arguments[_i + 0];\n        }\n        if (!this.active) {\n            return;\n        }\n        var n = this._bindings.length;\n        var bindings;\n        if (this.memorize) {\n            this._prevParams = paramsArr;\n        }\n        if (!n) {\n            return;\n        }\n        bindings = this._bindings.slice(0);\n        this._shouldPropagate = true;\n        do {\n            n--;\n        } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);\n    };\n    Signal.prototype.forget = function () {\n        this._prevParams = null;\n    };\n    Signal.prototype.dispose = function () {\n        this.removeAll();\n        delete this._bindings;\n        delete this._prevParams;\n    };\n    Signal.prototype.toString = function () {\n        return '[Signal active:' + this.active + ' numListeners:' + this.getNumListeners() + ']';\n    };\n    Signal.VERSION = '1.0.0';\n    window.Signal = Signal;\n    return Signal;\n}();\n","mh['CommTower'] = function (Signal) {\n    return {\n        requestState: new Signal(),\n        pause: new Signal(),\n        resume: new Signal()\n    };\n}(mh['Signal']);\n","/*\n\tHandles game states. Also fires off resource loading done by states, and acts as proxy between the Engine and States.\n\t\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh['StateManager'] = function (require, Kai, CommTower) {\n    var Kai = mh['Kai'];\n    var Tower = mh['CommTower'];\n    var StateManager = function () {\n        this.states = {};\n        this.currentStateName = null;\n        this.currentState = null;\n        this.ready = false;\n        this.queue = [];\n    };\n    StateManager.prototype = {\n        init: function () {\n            Tower.requestState.add(this.switchState, this);\n            Kai.load.onLoadComplete.add(this.loadComplete, this);\n            this.next();\n        },\n        add: function (key, StateObj) {\n            if (this.checkState(key, StateObj) === false) {\n                return;\n            }\n            this.states[key] = StateObj;\n            return StateObj;\n        },\n        remove: function (key) {\n            delete this.states[key];\n        },\n        switchState: function (key, clearCache) {\n            if (!this.states[key]) {\n                console.warn('[StateManager.switchState] ' + key + ' not found');\n                return;\n            }\n            this.ready = false;\n            this.queue.push(key);\n            if (typeof clearCache === 'undefined') {\n                clearCache = false;\n            }\n            this.next(clearCache);\n        },\n        next: function (clearCache) {\n            if (this.queue.length === 0 || Kai.ready === false) {\n                console.log('[StateManager.next] Queue length: ' + this.queue.length + '; Engine ready: ' + Kai.ready);\n                return;\n            }\n            Kai.inputBlocked = true;\n            if (clearCache) {\n                Kai.cache.dispose();\n            }\n            if (!!this.currentStateName) {\n                this.currentState = this.states[this.currentStateName];\n                this.currentState.dispose();\n            }\n            this.currentStateName = this.queue.shift();\n            this.currentState = this.states[this.currentStateName];\n            Kai.load.reset();\n            this.currentState.preload();\n            Kai.load.start();\n        },\n        checkState: function (key, state) {\n            var valid = false;\n            if (!!this.states[key]) {\n                console.error('[StateManager.checkState] Duplicate key: ' + key);\n                return false;\n            }\n            if (typeof state === 'function') {\n                console.error('[StateManager.switchState] States must be object literals, not functions');\n                return false;\n            }\n            if (!!state) {\n                if (state.preload && state.create && state.update && state.dispose) {\n                    valid = true;\n                }\n                if (!valid) {\n                    console.error('[StateManager.checkState] Invalid State \"' + key + '\" given. Must contain all required functions: preload, create, update, dispose');\n                    return false;\n                }\n                return true;\n            } else {\n                console.error('[StateManager.checkState] No state found with the key: ' + key);\n                return false;\n            }\n            return valid;\n        },\n        loadComplete: function () {\n            this.currentState.create();\n            Kai.inputBlocked = false;\n            this.ready = true;\n        },\n        dispose: function () {\n            this.states = null;\n            this.queue = null;\n        }\n    };\n    return StateManager;\n}({}, mh['Kai'], mh['CommTower']);\n","/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2013 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\nmh['RequestAnimationFrame'] = function () {\n    var RequestAnimationFrame = function (game) {\n        var vendors = [\n            'ms',\n            'moz',\n            'webkit',\n            'o'\n        ];\n        this.game = game;\n        this.isRunning = false;\n        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n            window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n            window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'];\n        }\n        this._isSetTimeOut = false;\n        this._onLoop = null;\n        this._timeOutID = null;\n    };\n    RequestAnimationFrame.prototype = {\n        start: function () {\n            this.isRunning = true;\n            var _this = this;\n            if (!window.requestAnimationFrame) {\n                this._isSetTimeOut = true;\n                this._onLoop = function () {\n                    return _this.updateSetTimeout();\n                };\n                this._timeOutID = window.setTimeout(this._onLoop, 0);\n            } else {\n                this._isSetTimeOut = false;\n                this._onLoop = function (time) {\n                    return _this.updateRAF(time);\n                };\n                this._timeOutID = window.requestAnimationFrame(this._onLoop);\n            }\n        },\n        updateRAF: function (time) {\n            this.game.update(time);\n            this._timeOutID = window.requestAnimationFrame(this._onLoop);\n        },\n        updateSetTimeout: function () {\n            this.game.update(Date.now());\n            this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);\n        },\n        stop: function () {\n            if (this._isSetTimeOut) {\n                clearTimeout(this._timeOutID);\n            } else {\n                window.cancelAnimationFrame(this._timeOutID);\n            }\n            this.isRunning = false;\n        },\n        isSetTimeOut: function () {\n            return this._isSetTimeOut;\n        },\n        isRAF: function () {\n            return this._isSetTimeOut === false;\n        }\n    };\n    return RequestAnimationFrame;\n}();\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2013 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\nmh['Loader'] = function (require, Kai) {\n    var Kai = mh['Kai'];\n    var Loader = function () {\n        this.baseURL = '';\n        this.crossOrigin = '';\n        this.isLoading = false;\n        this.progress = 0;\n        this.onFileComplete = new Signal();\n        this.onFileError = new Signal();\n        this.onLoadStart = new Signal();\n        this.onLoadComplete = new Signal();\n        this._fileList = [];\n        this._fileIndex = 0;\n        this._xhr = new XMLHttpRequest();\n    };\n    Loader.prototype = {\n        image: function (key, url, overwrite) {\n            if (typeof overwrite === 'undefined') {\n                overwrite = false;\n            }\n            if (overwrite) {\n                this._replaceInFileList('image', key, url);\n            } else {\n                this._addToFileList('image', key, url);\n            }\n            return this;\n        },\n        spritesheet: function (key, url, frameWidth, frameHeight, frameMax) {\n            if (typeof frameMax === 'undefined') {\n                frameMax = -1;\n            }\n            this._addToFileList('spritesheet', key, url, {\n                frameWidth: frameWidth,\n                frameHeight: frameHeight,\n                frameMax: frameMax\n            });\n            return this;\n        },\n        text: function (key, url, overwrite) {\n            if (typeof overwrite === 'undefined') {\n                overwrite = false;\n            }\n            if (overwrite) {\n                this._replaceInFileList('text', key, url);\n            } else {\n                this._addToFileList('text', key, url);\n            }\n            return this;\n        },\n        audio: function (key, urls, autoDecode) {\n            if (typeof autoDecode === 'undefined') {\n                autoDecode = true;\n            }\n            this.addToFileList('audio', key, urls, {\n                buffer: null,\n                autoDecode: autoDecode\n            });\n            return this;\n        },\n        removeFile: function (type, key) {\n            var file = this.getAsset(type, key);\n            if (file !== false) {\n                this._fileList.splice(file.index, 1);\n            }\n        },\n        removeAll: function () {\n            this._fileList.length = 0;\n        },\n        start: function () {\n            if (this.isLoading) {\n                return;\n            }\n            this.progress = 0;\n            this.hasLoaded = false;\n            this.isLoading = true;\n            this.onLoadStart.dispatch(this._fileList.length);\n            if (this._fileList.length > 0) {\n                this._fileIndex = 0;\n                this._progressChunk = 100 / this._fileList.length;\n                this._loadFile();\n            } else {\n                this.progress = 100;\n                this.hasLoaded = true;\n                this.onLoadComplete.dispatch();\n            }\n        },\n        reset: function () {\n            this.preloadSprite = null;\n            this.isLoading = false;\n            this._fileList.length = 0;\n            this._fileIndex = 0;\n        },\n        getAsset: function (type, key) {\n            if (this._fileList.length > 0) {\n                for (var i = 0; i < this._fileList.length; i++) {\n                    if (this._fileList[i].type === type && this._fileList[i].key === key) {\n                        return {\n                            index: i,\n                            file: this._fileList[i]\n                        };\n                    }\n                }\n            }\n            return false;\n        },\n        totalLoadedFiles: function () {\n            var total = 0;\n            for (var i = 0; i < this._fileList.length; i++) {\n                if (this._fileList[i].loaded) {\n                    total++;\n                }\n            }\n            return total;\n        },\n        totalQueuedFiles: function () {\n            var i, total = 0;\n            for (i = 0; i < this._fileList.length; i++) {\n                if (this._fileList[i].loaded === false) {\n                    total++;\n                }\n            }\n            return total;\n        },\n        checkKeyExists: function (type, key) {\n            if (this._fileList.length > 0) {\n                for (var i = 0; i < this._fileList.length; i++) {\n                    if (this._fileList[i].type === type && this._fileList[i].key === key) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _addToFileList: function (type, key, url, properties) {\n            var entry = {\n                type: type,\n                key: key,\n                url: url,\n                data: null,\n                error: false,\n                loaded: false\n            };\n            if (typeof properties !== 'undefined') {\n                for (var prop in properties) {\n                    entry[prop] = properties[prop];\n                }\n            }\n            if (this.checkKeyExists(type, key)) {\n                console.warn('[Loader] \"' + key + '\" already exists, use overwrite if you want to replace it in cache');\n            } else {\n                this._fileList.push(entry);\n            }\n        },\n        _replaceInFileList: function (type, key, url, properties) {\n            var entry = {\n                type: type,\n                key: key,\n                url: url,\n                data: null,\n                error: false,\n                loaded: false\n            };\n            if (typeof properties !== 'undefined') {\n                for (var prop in properties) {\n                    entry[prop] = properties[prop];\n                }\n            }\n            if (this.checkKeyExists(type, key) === false) {\n                this._fileList.push(entry);\n            }\n        },\n        _loadFile: function () {\n            if (!this._fileList[this._fileIndex]) {\n                console.warn('Phaser.Loader _loadFile invalid index ' + this._fileIndex);\n                return;\n            }\n            var file = this._fileList[this._fileIndex];\n            var self = this;\n            switch (file.type) {\n            case 'image':\n            case 'spritesheet':\n            case 'textureatlas':\n            case 'bitmapfont':\n            case 'tileset':\n                file.data = new Image();\n                file.data.name = file.key;\n                file.data.onload = function () {\n                    return self._fileComplete(self._fileIndex);\n                };\n                file.data.onerror = function () {\n                    return self._fileError(self._fileIndex);\n                };\n                file.data.crossOrigin = this.crossOrigin;\n                file.data.src = this.baseURL + file.url;\n                break;\n            case 'audio':\n                break;\n            case 'text':\n                this._xhr.open('GET', this.baseURL + file.url, true);\n                this._xhr.responseType = 'text';\n                this._xhr.onload = function () {\n                    return self._fileComplete(self._fileIndex);\n                };\n                this._xhr.onerror = function () {\n                    return self._fileError(self._fileIndex);\n                };\n                this._xhr.send();\n                break;\n            }\n        },\n        _nextFile: function (previousIndex, success) {\n            this.progress = Math.round(this.progress + this._progressChunk);\n            if (this.progress > 100) {\n                this.progress = 100;\n            }\n            if (this.preloadSprite !== null) {\n                if (this.preloadSprite.direction === 0) {\n                    this.preloadSprite.crop.width = Math.floor(this.preloadSprite.width / 100 * this.progress);\n                } else {\n                    this.preloadSprite.crop.height = Math.floor(this.preloadSprite.height / 100 * this.progress);\n                }\n                this.preloadSprite.sprite.crop = this.preloadSprite.crop;\n            }\n            this.onFileComplete.dispatch(this.progress, this._fileList[previousIndex].key, success, this.totalLoadedFiles(), this._fileList.length);\n            if (this.totalQueuedFiles() > 0) {\n                this._fileIndex++;\n                this._loadFile();\n            } else {\n                this.hasLoaded = true;\n                this.isLoading = false;\n                this.removeAll();\n                this.onLoadComplete.dispatch();\n            }\n        },\n        _getAudioURL: function (urls) {\n            return null;\n        },\n        _fileError: function (index) {\n            this._fileList[index].loaded = true;\n            this._fileList[index].error = true;\n            this.on_fileError.dispatch(this._fileList[index].key, this._fileList[index]);\n            console.warn('Phaser.Loader error loading file: ' + this._fileList[index].key + ' from URL ' + this._fileList[index].url);\n            this._nextFile(index, false);\n        },\n        _fileComplete: function (index) {\n            if (!this._fileList[index]) {\n                console.warn('Phaser.Loader _fileComplete invalid index ' + index);\n                return;\n            }\n            var file = this._fileList[index];\n            file.loaded = true;\n            var loadNext = true;\n            var self = this;\n            switch (file.type) {\n            case 'image':\n                Kai.cache.addImage(file.key, file.url, file.data);\n                break;\n            case 'spritesheet':\n                Kai.cache.addSpriteSheet(file.key, file.url, file.data, file.frameWidth, file.frameHeight, file.frameMax);\n                break;\n            case 'tileset':\n                Kai.cache.addTileset(file.key, file.url, file.data, file.tileWidth, file.tileHeight, file.tileMax, file.tileMargin, file.tileSpacing);\n                break;\n            case 'audio':\n                break;\n            case 'text':\n                file.data = this._xhr.responseText;\n                Kai.cache.addText(file.key, file.url, file.data);\n                break;\n            case 'script':\n                file.data = document.createElement('script');\n                file.data.language = 'javascript';\n                file.data.type = 'text/javascript';\n                file.data.defer = false;\n                file.data.text = this._xhr.responseText;\n                document.head.appendChild(file.data);\n                break;\n            }\n            if (loadNext) {\n                this._nextFile(index, true);\n            }\n        },\n        _jsonLoadComplete: function (index) {\n            if (!this._fileList[index]) {\n                console.warn('Phaser.Loader _jsonLoadComplete invalid index ' + index);\n                return;\n            }\n            var file = this._fileList[index];\n            var data = JSON.parse(this._xhr.responseText);\n            file.loaded = true;\n            if (file.type === 'tilemap') {\n                Kai.cache.addTilemap(file.key, file.url, data, file.format);\n            } else {\n                Kai.cache.addTextureAtlas(file.key, file.url, file.data, data, file.format);\n            }\n            this._nextFile(index, true);\n        }\n    };\n    return Loader;\n}({}, mh['Kai']);\n","/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2013 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\nmh['Cache'] = function () {\n    var Cache = function () {\n        this._canvases = {};\n        this._images = {};\n        this._textures = {};\n        this._sounds = {};\n        this._text = {};\n        this._tilemaps = {};\n        this._tilesets = {};\n        this._bitmapDatas = {};\n        this.addDefaultImage();\n        this.addMissingImage();\n        this.onSoundUnlock = new Signal();\n    };\n    Cache.prototype = {\n        addCanvas: function (key, canvas, context) {\n            this._canvases[key] = {\n                canvas: canvas,\n                context: context\n            };\n        },\n        addBitmapData: function (key, bitmapData) {\n            this._bitmapDatas[key] = bitmapData;\n            return bitmapData;\n        },\n        addSpriteSheet: function (key, url, data, frameWidth, frameHeight, frameMax) {\n        },\n        addTileset: function (key, url, data, tileWidth, tileHeight, tileMax, tileMargin, tileSpacing) {\n        },\n        addTilemap: function (key, url, mapData, format) {\n        },\n        addTextureAtlas: function (key, url, data, atlasData, format) {\n        },\n        addBitmapFont: function (key, url, data, xmlData) {\n        },\n        addDefaultImage: function () {\n            var img = new Image();\n            img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==';\n            this._images['__default'] = {\n                url: null,\n                data: img,\n                spriteSheet: false\n            };\n        },\n        addMissingImage: function () {\n            var img = new Image();\n            img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==';\n            this._images['__missing'] = {\n                url: null,\n                data: img,\n                spriteSheet: false\n            };\n        },\n        addText: function (key, url, data) {\n            this._text[key] = {\n                url: url,\n                data: data\n            };\n        },\n        addImage: function (key, url, data) {\n            this._images[key] = {\n                url: url,\n                data: data,\n                spriteSheet: false\n            };\n        },\n        addSound: function (key, url, data, webAudio, audioTag) {\n            webAudio = webAudio || true;\n            audioTag = audioTag || false;\n            var decoded = false;\n            if (audioTag) {\n                decoded = true;\n            }\n            this._sounds[key] = {\n                url: url,\n                data: data,\n                isDecoding: false,\n                decoded: decoded,\n                webAudio: webAudio,\n                audioTag: audioTag\n            };\n        },\n        reloadSound: function (key) {\n            var _this = this;\n            if (this._sounds[key]) {\n                this._sounds[key].data.src = this._sounds[key].url;\n                this._sounds[key].data.addEventListener('canplaythrough', function () {\n                    return _this.reloadSoundComplete(key);\n                }, false);\n                this._sounds[key].data.load();\n            }\n        },\n        reloadSoundComplete: function (key) {\n            if (this._sounds[key]) {\n                this._sounds[key].locked = false;\n                this.onSoundUnlock.dispatch(key);\n            }\n        },\n        updateSound: function (key, property, value) {\n            if (this._sounds[key]) {\n                this._sounds[key][property] = value;\n            }\n        },\n        decodedSound: function (key, data) {\n            this._sounds[key].data = data;\n            this._sounds[key].decoded = true;\n            this._sounds[key].isDecoding = false;\n        },\n        getCanvas: function (key) {\n            if (this._canvases[key]) {\n                return this._canvases[key].canvas;\n            }\n            return null;\n        },\n        getBitmapData: function (key) {\n            if (this._bitmapDatas[key]) {\n                return this._bitmapDatas[key];\n            }\n            return null;\n        },\n        checkImageKey: function (key) {\n            if (this._images[key]) {\n                return true;\n            }\n            return false;\n        },\n        getImage: function (key) {\n            if (this._images[key]) {\n                return this._images[key].data;\n            }\n            console.warn('[Cache.getImage] ' + key + ' does not exist in cache--did you forget to load it?');\n            return null;\n        },\n        getTilesetImage: function (key) {\n            if (this._tilesets[key]) {\n                return this._tilesets[key].data;\n            }\n            return null;\n        },\n        getTileset: function (key) {\n            if (this._tilesets[key]) {\n                return this._tilesets[key].tileData;\n            }\n            return null;\n        },\n        getTilemapData: function (key) {\n            if (this._tilemaps[key]) {\n                return this._tilemaps[key];\n            }\n            return null;\n        },\n        getFrameData: function (key) {\n            if (this._images[key] && this._images[key].frameData) {\n                return this._images[key].frameData;\n            }\n            return null;\n        },\n        getFrameByIndex: function (key, frame) {\n            if (this._images[key] && this._images[key].frameData) {\n                return this._images[key].frameData.getFrame(frame);\n            }\n            return null;\n        },\n        getFrameByName: function (key, frame) {\n            if (this._images[key] && this._images[key].frameData) {\n                return this._images[key].frameData.getFrameByName(frame);\n            }\n            return null;\n        },\n        getFrame: function (key) {\n            if (this._images[key] && this._images[key].spriteSheet === false) {\n                return this._images[key].frame;\n            }\n            return null;\n        },\n        getTextureFrame: function (key) {\n            if (this._textures[key]) {\n                return this._textures[key].frame;\n            }\n            return null;\n        },\n        getTexture: function (key) {\n            if (this._textures[key]) {\n                return this._textures[key];\n            }\n            return null;\n        },\n        getSound: function (key) {\n            if (this._sounds[key]) {\n                return this._sounds[key];\n            }\n            return null;\n        },\n        getSoundData: function (key) {\n            if (this._sounds[key]) {\n                return this._sounds[key].data;\n            }\n            return null;\n        },\n        isSoundDecoded: function (key) {\n            if (this._sounds[key]) {\n                return this._sounds[key].decoded;\n            }\n        },\n        isSoundReady: function (key) {\n            return this._sounds[key] && this._sounds[key].decoded && this.game.sound.touchLocked === false;\n        },\n        isSpriteSheet: function (key) {\n            if (this._images[key]) {\n                return this._images[key].spriteSheet;\n            }\n            return false;\n        },\n        getText: function (key) {\n            if (this._text[key]) {\n                return this._text[key].data;\n            }\n            return null;\n        },\n        getKeys: function (array) {\n            var item, output = [];\n            for (item in array) {\n                if (item !== '__default') {\n                    output.push(item);\n                }\n            }\n            return output;\n        },\n        getImageKeys: function () {\n            return this.getKeys(this._images);\n        },\n        getSoundKeys: function () {\n            return this.getKeys(this._sounds);\n        },\n        getTextKeys: function () {\n            return this.getKeys(this._text);\n        },\n        removeCanvas: function (key) {\n            delete this._canvases[key];\n        },\n        removeImage: function (key) {\n            delete this._images[key];\n        },\n        removeSound: function (key) {\n            delete this._sounds[key];\n        },\n        removeText: function (key) {\n            delete this._text[key];\n        },\n        dispose: function () {\n            var item;\n            for (item in this._canvases) {\n                delete this._canvases[item['key']];\n            }\n            for (item in this._images) {\n                delete this._images[item['key']];\n            }\n            for (item in this._sounds) {\n                delete this._sounds[item['key']];\n            }\n            for (item in this._text) {\n                delete this._text[item['key']];\n            }\n        }\n    };\n    return Cache;\n}();\n","mh['MouseController'] = function (Kai) {\n    return function MouseController() {\n        this.position = new Vec2();\n        this.onDown = new Signal();\n        this.onUp = new Signal();\n        this.down = false;\n        this.shift = false;\n        this.ctrl = false;\n        var _self = this, _downPrev = false;\n        function onDown(evt) {\n            if (Kai.inputBlocked) {\n                return;\n            }\n            _self.position.x = evt.pageX;\n            _self.position.y = evt.pageY;\n            _self.down = true;\n            _self.shift = !!evt.shiftKey;\n            _self.ctrl = !!evt.ctrlKey;\n            _self.onDown.dispatch(_self.position);\n        }\n        function onUp(evt) {\n            if (!_self.down || Kai.inputBlocked) {\n                return;\n            }\n            _self.position.x = evt.pageX;\n            _self.position.y = evt.pageY;\n            _self.down = false;\n            _self.shift = !!evt.shiftKey;\n            _self.ctrl = !!evt.ctrlKey;\n            _self.onUp.dispatch(_self.position);\n        }\n        function onMove(evt) {\n            evt.preventDefault();\n            _self.position.x = evt.pageX;\n            _self.position.y = evt.pageY;\n            _self.shift = !!evt.shiftKey;\n            _self.ctrl = !!evt.ctrlKey;\n        }\n        function onContext(evt) {\n            evt.preventDefault();\n            return false;\n        }\n        (function init() {\n            document.addEventListener('mousedown', onDown, false);\n            document.addEventListener('mouseup', onUp, false);\n            document.addEventListener('mouseout', onUp, false);\n            document.addEventListener('mousemove', onMove, false);\n            document.addEventListener('contextmenu', onContext, false);\n        }());\n    };\n}(mh['Kai']);\n","mh['KeyboardController'] = function (Kai) {\n    var KeyboardController = function () {\n        this.key = -1;\n        this.onDown = new Signal();\n        this.onUp = new Signal();\n        this.shift = false;\n        this.ctrl = false;\n        this._keys = {};\n        this._prev = null;\n        document.addEventListener('keydown', this._processDown.bind(this), false);\n        document.addEventListener('keyup', this._processUp.bind(this), false);\n    };\n    KeyboardController.prototype = {\n        _processDown: function (evt) {\n            var key = this._keys[evt.keyCode];\n            if (Kai.inputBlocked || this.key === this._prev) {\n                return;\n            }\n            this.shift = !!evt.shiftKey;\n            this.ctrl = !!evt.ctrlKey;\n            this.key = evt.keyCode;\n            if (key && key.isDown) {\n                this._keys[evt.keyCode].duration = performance.now() - key.timeDown;\n            } else {\n                if (!key) {\n                    this._keys[evt.keyCode] = {\n                        isDown: true,\n                        timeDown: performance.now(),\n                        timeUp: 0,\n                        duration: 0\n                    };\n                } else {\n                    this._keys[evt.keyCode].isDown = true;\n                    this._keys[evt.keyCode].timeDown = performance.now();\n                    this._keys[evt.keyCode].duration = 0;\n                }\n            }\n            this.onDown.dispatch(this.key);\n            this._prev = this.key;\n        },\n        _processUp: function (evt) {\n            if (Kai.inputBlocked) {\n                return;\n            }\n            this.key = -1;\n            this.shift = false;\n            this.ctrl = false;\n            if (this._keys[evt.keyCode]) {\n                this._keys[evt.keyCode].isDown = false;\n                this._keys[evt.keyCode].timeUp = performance.now();\n            } else {\n                this._keys[evt.keyCode] = {\n                    isDown: false,\n                    timeDown: performance.now(),\n                    timeUp: performance.now(),\n                    duration: 0\n                };\n            }\n            this.onUp.dispatch(evt.keyCode, this._keys[evt.keyCode].timeUp - this._keys[evt.keyCode].timeDown);\n        },\n        activate: function () {\n            for (var key in this._keys) {\n                this._keys[key].isDown = false;\n            }\n        },\n        justPressed: function (keycode, duration) {\n            if (typeof duration === 'undefined') {\n                duration = 100;\n            }\n            if (this._keys[keycode] && this._keys[keycode].isDown && this._keys[keycode].duration < duration) {\n                return true;\n            }\n            return false;\n        },\n        justReleased: function (keycode, duration) {\n            if (typeof duration === 'undefined') {\n                duration = 100;\n            }\n            if (this._keys[keycode] && this._keys[keycode].isDown === false && performance.now() - this._keys[keycode].timeUp < duration) {\n                return true;\n            }\n            return false;\n        },\n        isDown: function (keycode) {\n            if (this._keys[keycode]) {\n                return this._keys[keycode].isDown;\n            }\n            return false;\n        },\n        A: 'A'.charCodeAt(0),\n        B: 'B'.charCodeAt(0),\n        C: 'C'.charCodeAt(0),\n        D: 'D'.charCodeAt(0),\n        E: 'E'.charCodeAt(0),\n        F: 'F'.charCodeAt(0),\n        G: 'G'.charCodeAt(0),\n        H: 'H'.charCodeAt(0),\n        I: 'I'.charCodeAt(0),\n        J: 'J'.charCodeAt(0),\n        K: 'K'.charCodeAt(0),\n        L: 'L'.charCodeAt(0),\n        M: 'M'.charCodeAt(0),\n        N: 'N'.charCodeAt(0),\n        O: 'O'.charCodeAt(0),\n        P: 'P'.charCodeAt(0),\n        Q: 'Q'.charCodeAt(0),\n        R: 'R'.charCodeAt(0),\n        S: 'S'.charCodeAt(0),\n        T: 'T'.charCodeAt(0),\n        U: 'U'.charCodeAt(0),\n        V: 'V'.charCodeAt(0),\n        W: 'W'.charCodeAt(0),\n        X: 'X'.charCodeAt(0),\n        Y: 'Y'.charCodeAt(0),\n        Z: 'Z'.charCodeAt(0),\n        ZERO: '0'.charCodeAt(0),\n        ONE: '1'.charCodeAt(0),\n        TWO: '2'.charCodeAt(0),\n        THREE: '3'.charCodeAt(0),\n        FOUR: '4'.charCodeAt(0),\n        FIVE: '5'.charCodeAt(0),\n        SIX: '6'.charCodeAt(0),\n        SEVEN: '7'.charCodeAt(0),\n        EIGHT: '8'.charCodeAt(0),\n        NINE: '9'.charCodeAt(0),\n        NUMPAD_0: 96,\n        NUMPAD_1: 97,\n        NUMPAD_2: 98,\n        NUMPAD_3: 99,\n        NUMPAD_4: 100,\n        NUMPAD_5: 101,\n        NUMPAD_6: 102,\n        NUMPAD_7: 103,\n        NUMPAD_8: 104,\n        NUMPAD_9: 105,\n        NUMPAD_MULTIPLY: 106,\n        NUMPAD_ADD: 107,\n        NUMPAD_ENTER: 108,\n        NUMPAD_SUBTRACT: 109,\n        NUMPAD_DECIMAL: 110,\n        NUMPAD_DIVIDE: 111,\n        F1: 112,\n        F2: 113,\n        F3: 114,\n        F4: 115,\n        F5: 116,\n        F6: 117,\n        F7: 118,\n        F8: 119,\n        F9: 120,\n        F10: 121,\n        F11: 122,\n        F12: 123,\n        F13: 124,\n        F14: 125,\n        F15: 126,\n        COLON: 186,\n        EQUALS: 187,\n        UNDERSCORE: 189,\n        QUESTION_MARK: 191,\n        TILDE: 192,\n        OPEN_BRACKET: 219,\n        BACKWARD_SLASH: 220,\n        CLOSED_BRACKET: 221,\n        QUOTES: 222,\n        BACKSPACE: 8,\n        TAB: 9,\n        CLEAR: 12,\n        ENTER: 13,\n        SHIFT: 16,\n        CONTROL: 17,\n        ALT: 18,\n        CAPS_LOCK: 20,\n        ESC: 27,\n        SPACEBAR: 32,\n        PAGE_UP: 33,\n        PAGE_DOWN: 34,\n        END: 35,\n        HOME: 36,\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        DOWN: 40,\n        INSERT: 45,\n        DELETE: 46,\n        HELP: 47,\n        NUM_LOCK: 144\n    };\n    return KeyboardController;\n}(mh['Kai']);\n","/*\n\tThe Engine holds the state manager, fires it off when the document is ready, and runs the one and only update loop. It ties all the other core modules together, setting everything up.\n\t\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh['Engine'] = function (require, Kai, CommTower, StateManager, RequestAnimationFrame, Loader, Cache, MouseController, KeyboardController) {\n    var Kai = mh['Kai'];\n    var Tower = mh['CommTower'];\n    var StateManager = mh['StateManager'];\n    var RAF = mh['RequestAnimationFrame'];\n    var Loader = mh['Loader'];\n    var Cache = mh['Cache'];\n    var MouseController = mh['MouseController'];\n    var KeyboardController = mh['KeyboardController'];\n    var Engine = function () {\n        if (Kai.debugMessages) {\n            console.log('[Engine] Initializing');\n        }\n        this.state = new StateManager();\n        this.raf = new RAF(this);\n        this._paused = false;\n        var self = this;\n        this._onInit = function () {\n            return self.init();\n        };\n        if (document.readyState === 'complete' || document.readyState === 'interactive') {\n            window.setTimeout(this._onInit, 0);\n        } else {\n            document.addEventListener('DOMContentLoaded', this._onInit, false);\n            window.addEventListener('load', this._onInit, false);\n        }\n    };\n    Engine.prototype = {\n        constructor: Engine,\n        init: function () {\n            if (Kai.ready) {\n                return;\n            }\n            var self = this;\n            if (!document.body) {\n                window.setTimeout(this._onInit, 20);\n                return;\n            }\n            document.removeEventListener('DOMContentLoaded', this._onInit);\n            window.removeEventListener('load', this._onInit);\n            window.addEventListener('focus', function (evt) {\n                self._paused = false;\n                Tower.resume.dispatch();\n            }, false);\n            window.addEventListener('blur', function (evt) {\n                self._paused = true;\n                Tower.pause.dispatch();\n            }, false);\n            Kai.engine = this;\n            Kai.mouse = new MouseController();\n            Kai.keys = new KeyboardController();\n            Kai.cache = new Cache();\n            Kai.load = new Loader();\n            Kai.ready = true;\n            this.state.init();\n            Kai.inputBlocked = false;\n            if (Kai.debugMessages) {\n                console.log('[Engine] Ready');\n            }\n            this.raf.start();\n        },\n        start: function (state) {\n            if (Kai.ready) {\n                return;\n            }\n            this.state.switchState(state);\n        },\n        update: function () {\n            var i, node, obj, list = Kai.componentsSorted, len = list.length;\n            if (this._paused) {\n                return;\n            }\n            if (this.state.ready) {\n                if (Kai.debugCtx) {\n                    Kai.debugCtx.clearRect(0, 0, Kai.width, Kai.height);\n                }\n                for (i = 0; i < len; i++) {\n                    if (!list[i])\n                        continue;\n                    node = list[i].first;\n                    if (node && !node.obj.update) {\n                        continue;\n                    }\n                    while (node) {\n                        obj = node.obj;\n                        if (obj.active) {\n                            obj.update();\n                        }\n                        node = node.next;\n                    }\n                }\n                this.state.currentState.update();\n            } else {\n            }\n            if (Kai.renderHook) {\n                Kai.renderHook();\n            }\n        },\n        dispose: function () {\n        }\n    };\n    return Engine;\n}({}, mh['Kai'], mh['CommTower'], mh['StateManager'], mh['RequestAnimationFrame'], mh['Loader'], mh['Cache'], mh['MouseController'], mh['KeyboardController']);\n","// JavaScript utility functions\nmh['Tools'] = {\n    PI: Math.PI,\n    TAU: Math.PI * 2,\n    DEG_TO_RAD: 0.0174532925,\n    RAD_TO_DEG: 57.2957795,\n    clamp: function (val, min, max) {\n        return Math.max(min, Math.min(max, val));\n    },\n    sign: function (val) {\n        return val && val / Math.abs(val);\n    },\n    random: function (min, max) {\n        if (arguments.length === 1) {\n            return Math.random() * min - min * 0.5;\n        }\n        return Math.random() * (max - min) + min;\n    },\n    randomInt: function (min, max) {\n        if (arguments.length === 1) {\n            return Math.floor(Math.random() * min - min * 0.5);\n        }\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    },\n    normalize: function (v, min, max) {\n        return (v - min) / (max - min);\n    },\n    getShortRotation: function (angle) {\n        angle %= this.TAU;\n        if (angle > this.PI) {\n            angle -= this.TAU;\n        } else if (angle < -this.PI) {\n            angle += this.TAU;\n        }\n        return angle;\n    },\n    generateID: function () {\n        return Math.random().toString(36).slice(2) + Date.now();\n    },\n    isPlainObject: function (obj) {\n        if (typeof obj !== 'object' || obj.nodeType || obj === obj.window) {\n            return false;\n        }\n        try {\n            if (obj.constructor && !Object.prototype.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {\n                return false;\n            }\n        } catch (e) {\n            return false;\n        }\n        return true;\n    },\n    merge: function () {\n        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;\n        if (typeof target === 'boolean') {\n            deep = target;\n            target = arguments[1] || {};\n            i = 2;\n        }\n        for (; i < length; i++) {\n            if ((options = arguments[i]) !== null) {\n                for (name in options) {\n                    src = target[name];\n                    copy = options[name];\n                    if (target === copy) {\n                        continue;\n                    }\n                    if (deep && copy && (this.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n                        if (copyIsArray) {\n                            copyIsArray = false;\n                            clone = src && Array.isArray(src) ? src : [];\n                        } else {\n                            clone = src && this.isPlainObject(src) ? src : {};\n                        }\n                        target[name] = this.extend(deep, clone, copy);\n                    } else if (copy !== undefined) {\n                        target[name] = copy;\n                    }\n                }\n            }\n        }\n        return target;\n    },\n    now: function () {\n        return window.nwf ? window.nwf.system.Performance.elapsedTime : window.performance.now();\n    },\n    empty: function (node) {\n        while (node.lastChild) {\n            node.removeChild(node.lastChild);\n        }\n    },\n    radixSort: function (arr, idx_begin, idx_end, bit) {\n        idx_begin = idx_begin || 0;\n        idx_end = idx_end || arr.length;\n        bit = bit || 31;\n        if (idx_begin >= idx_end - 1 || bit < 0) {\n            return;\n        }\n        var idx = idx_begin;\n        var idx_ones = idx_end;\n        var mask = 1 << bit;\n        while (idx < idx_ones) {\n            if (arr[idx] & mask) {\n                --idx_ones;\n                var tmp = arr[idx];\n                arr[idx] = arr[idx_ones];\n                arr[idx_ones] = tmp;\n            } else {\n                ++idx;\n            }\n        }\n        this.radixSort(arr, idx_begin, idx_ones, bit - 1);\n        this.radixSort(arr, idx_ones, idx_end, bit - 1);\n    }\n};\n","mh['World'] = function (require, Tools) {\n    var Tools = mh['Tools'];\n    return {\n        width: 1,\n        height: 1,\n        depth: 1,\n        scale: 1,\n        gravity: 8,\n        friction: 0.98,\n        elapsed: 0.01666,\n        broadphase: null,\n        map: null,\n        mainCamera: null,\n        cameras: null,\n        set: function (settings) {\n            Tools.merge(this, settings);\n        }\n    };\n}({}, mh['Tools']);\n","mh['PhysicsConstants'] = function (require) {\n    return {\n        BOUNDARY_WRAP: 'wrap',\n        BOUNDARY_BOUNCE: 'bounce',\n        BOUNDARY_DISABLE: 'disable'\n    };\n}({});\n","mh['DebugDraw'] = function () {\n    var tau = Math.PI * 2;\n    var DebugDraw = {\n        circle: function (ctx, x, y, radius, color) {\n            color = color || 'rgb(200, 10, 30)';\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, tau);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        },\n        point: function (ctx, p, radius, color) {\n            color = color || 'rgb(200, 10, 30)';\n            radius = radius || 3;\n            ctx.beginPath();\n            ctx.arc(p.x, p.y, radius, 0, tau);\n            ctx.fillStyle = color;\n            ctx.fill();\n        },\n        vector: function (ctx, v, offsetVec, color) {\n            color = color || 'rgb(200, 10, 30)';\n            ctx.beginPath();\n            ctx.moveTo(offsetVec.x, offsetVec.y);\n            ctx.lineTo(v.x + offsetVec.x, v.y + offsetVec.y);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        },\n        vectorLine: function (ctx, fromV, toV, color) {\n            color = color || 'rgb(200, 10, 30)';\n            ctx.beginPath();\n            ctx.moveTo(fromV.x, fromV.y);\n            ctx.lineTo(toV.x, toV.y);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        },\n        rectangle: function (ctx, x, y, sizeX, sizeY, color) {\n            color = color || 'rgb(200, 10, 30)';\n            ctx.beginPath();\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = color;\n            ctx.strokeRect(x - sizeX * 0.5, y - sizeY * 0.5, sizeX, sizeY);\n        }\n    };\n    return DebugDraw;\n}();\n","/*\n\tAll game objects must extend this, since many core components assume these properties exist on everything.\n\t\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmh['Base'] = function () {\n    var Base = function () {\n        this.uniqueId = Math.random().toString(36).slice(2) + Date.now();\n        this.active = false;\n    };\n    return Base;\n}();\n","mh['AABB2'] = function (require, Kai, Tools, World, PhysicsConstants, DebugDraw, Base) {\n    var Kai = mh['Kai'];\n    var Tools = mh['Tools'];\n    var World = mh['World'];\n    var PhysicsConstants = mh['PhysicsConstants'];\n    var DebugDraw = mh['DebugDraw'];\n    var AABB2 = function (entity, settings) {\n        mh['Base'].call(this);\n        this.width = 50;\n        this.height = 50;\n        this.min = new Vec2();\n        this.max = new Vec2();\n        this.mass = 5;\n        this.invmass = 0;\n        this.restitution = 0.6;\n        this.solid = true;\n        this.hasAccel = false;\n        this.hasFriction = false;\n        this.autoAdd = true;\n        this.collisionId = this.uniqueId;\n        this.boundaryBehavior = PhysicsConstants.BOUNDARY_BOUNCE;\n        this.maxSpeed = entity.maxSpeed || 100;\n        Tools.merge(this, settings);\n        this.onCollision = new Signal();\n        this.entity = entity;\n        this._halfWidth = this.width / 2;\n        this._halfHeight = this.height / 2;\n        this.position = Kai.expect(entity, 'position', Vec2);\n        this.velocity = Kai.expect(entity, 'velocity', Vec2);\n        if (this.hasAccel) {\n            this.accel = Kai.expect(entity, 'accel', Vec2);\n        }\n        this.min.x = this.position.x - this._halfWidth;\n        this.min.y = this.position.y - this._halfHeight;\n        this.max.x = this.position.x + this._halfWidth;\n        this.max.y = this.position.y + this._halfHeight;\n        this.setMass(this.mass);\n    };\n    AABB2.accessor = 'body';\n    AABB2.className = 'BODY_AABB2';\n    AABB2.priority = 100;\n    AABB2.prototype = {\n        constructor: AABB2,\n        setMass: function (newMass) {\n            this.mass = newMass;\n            if (newMass <= 0) {\n                this.invmass = 0;\n            } else {\n                this.invmass = 1 / newMass;\n            }\n        },\n        activate: function () {\n            this.solid = true;\n            this.active = true;\n            if (this.autoAdd) {\n                World.broadphase.add(this);\n            }\n        },\n        disable: function () {\n            this.solid = false;\n            this.active = false;\n            if (this.autoAdd) {\n                World.broadphase.remove(this);\n            }\n        },\n        update: function () {\n            this.velocity.y += World.gravity;\n            if (this.hasAccel) {\n                this.velocity.x += this.accel.x;\n                this.velocity.y += this.accel.y;\n            }\n            this.velocity.truncate(this.maxSpeed);\n            if (this.hasFriction) {\n                this.velocity.x *= World.friction;\n                this.velocity.y *= World.friction;\n            }\n            this.position.x += this.velocity.x * World.elapsed;\n            this.position.y += this.velocity.y * World.elapsed;\n            switch (this.boundaryBehavior) {\n            case PhysicsConstants.BOUNDARY_DISABLE:\n                if (this.position.x < this.radius || this.position.x + this.radius > World.width || this.position.y < this.radius || this.position.y + this.radius > World.height) {\n                    this.onCollision.dispatch(null);\n                }\n                break;\n            case PhysicsConstants.BOUNDARY_BOUNCE:\n                if (this.position.x < this._halfWidth) {\n                    this.position.x = this._halfWidth;\n                    this.velocity.x = -this.velocity.x * this.restitution;\n                } else if (this.position.x + this._halfWidth > World.width) {\n                    this.position.x = World.width - this._halfWidth;\n                    this.velocity.x = -this.velocity.x * this.restitution;\n                }\n                if (this.position.y < this._halfWidth) {\n                    this.position.y = this._halfWidth;\n                    this.velocity.y = -this.velocity.y * this.restitution;\n                } else if (this.position.y + this._halfHeight > World.height) {\n                    this.position.y = World.height - this._halfHeight;\n                    this.velocity.y = -this.velocity.y * this.restitution;\n                }\n                break;\n            case PhysicsConstants.BOUNDARY_WRAP:\n                if (this.position.x < 0) {\n                    this.position.x += World.width;\n                } else if (this.position.x > World.width) {\n                    this.position.x -= World.width;\n                }\n                if (this.position.y < 0) {\n                    this.position.y += World.height;\n                } else if (this.position.y > World.height) {\n                    this.position.y -= World.height;\n                }\n                break;\n            }\n            this.min.x = this.position.x - this._halfWidth;\n            this.min.y = this.position.y - this._halfHeight;\n            this.max.x = this.position.x + this._halfWidth;\n            this.max.y = this.position.y + this._halfHeight;\n        },\n        debugDraw: function (ctx) {\n            if (World.camera) {\n                DebugDraw.rectangle(ctx, this.position.x - World.camera.position.x, this.position.y - World.camera.position.y, this.width, this.height);\n            } else {\n                DebugDraw.rectangle(ctx, this.position.x, this.position.y, this.width, this.height);\n            }\n        },\n        dispose: function () {\n            this.onCollision.dispose();\n            this.entity = null;\n            this.position = null;\n            this.velocity = null;\n            this.onCollision = null;\n        }\n    };\n    return AABB2;\n}({}, mh['Kai'], mh['Tools'], mh['World'], mh['PhysicsConstants'], mh['DebugDraw'], mh['Base']);\n","mh['AABB3'] = function (require, Tools, World, Base) {\n    var Tools = mh['Tools'];\n    var World = mh['World'];\n    var AABB3 = function (entity, settings) {\n        mh['Base'].call(this);\n        this.width = 50;\n        this.height = 50;\n        this.depth = 50;\n        this.min = new THREE.Vector3();\n        this.max = new THREE.Vector3();\n        this.mass = 100;\n        this.invmass = 0;\n        this.restitution = 0.6;\n        Tools.merge(this, settings);\n        this.entity = entity;\n        this._halfWidth = this.width / 2;\n        this._halfHeight = this.height / 2;\n        this._halfDepth = this.depth / 2;\n        this.position = entity.position;\n        this.velocity = entity.velocity;\n        this.min.x = this.position.x - this._halfWidth;\n        this.min.y = this.position.y - this._halfHeight;\n        this.min.z = this.position.z - this._halfDepth;\n        this.max.x = this.position.x + this._halfWidth;\n        this.max.y = this.position.y + this._halfHeight;\n        this.max.z = this.position.z + this._halfDepth;\n        this.setMass(this.mass);\n    };\n    AABB3.accessor = 'body';\n    AABB3.className = 'BODY_AABB3';\n    AABB3.priority = 1;\n    AABB3.prototype = {\n        constructor: AABB3,\n        setMass: function (newMass) {\n            this.mass = newMass;\n            if (newMass <= 0) {\n                this.invmass = 0;\n            } else {\n                this.invmass = 1 / newMass;\n            }\n        },\n        activate: function () {\n            this.setMass(this.mass);\n        },\n        update: function () {\n            this.velocity.y += World.gravity * World.elapsed;\n            this.position.x += this.velocity.x * World.elapsed;\n            this.position.y += this.velocity.y * World.elapsed;\n            this.position.z += this.velocity.z * World.elapsed;\n            if (this.position.x < 0) {\n                this.position.x = 0;\n                this.velocity.x = -this.velocity.x * this.restitution;\n            } else if (this.position.x + this._halfWidth > World.width) {\n                this.position.x = World.width - this._halfWidth;\n                this.velocity.x = -this.velocity.x * this.restitution;\n            }\n            if (this.position.y < 0) {\n                this.position.y = 0;\n                this.velocity.y = -this.velocity.y * this.restitution;\n            } else if (this.position.y + this._halfHeight > World.height) {\n                this.position.y = World.height - this._halfHeight;\n                this.velocity.y = -this.velocity.y * this.restitution;\n            }\n            this.min.x = this.position.x - this._halfWidth;\n            this.min.y = this.position.y - this._halfHeight;\n            this.min.z = this.position.z - this._halfDepth;\n            this.max.x = this.position.x + this._halfWidth;\n            this.max.y = this.position.y + this._halfHeight;\n            this.max.z = this.position.z + this._halfDepth;\n        },\n        dispose: function () {\n            this.entity = null;\n            this.position = null;\n            this.velocity = null;\n        }\n    };\n    return AABB3;\n}({}, mh['Tools'], mh['World'], mh['Base']);\n","mh['RadialCollider2'] = function (require, Kai, Tools, World, PhysicsConstants, DebugDraw, Base) {\n    var Kai = mh['Kai'];\n    var Tools = mh['Tools'];\n    var World = mh['World'];\n    var PhysicsConstants = mh['PhysicsConstants'];\n    var DebugDraw = mh['DebugDraw'];\n    var RadialColider2 = function (entity, settings) {\n        mh['Base'].call(this);\n        this.radius = 25;\n        this.mass = 5;\n        this.invmass = 0;\n        this.restitution = 0.8;\n        this.solid = true;\n        this.hasAccel = false;\n        this.hasFriction = false;\n        this.autoAdd = true;\n        this.collisionId = this.uniqueId;\n        this.boundaryBehavior = PhysicsConstants.BOUNDARY_BOUNCE;\n        this.maxSpeed = entity.maxSpeed || 100;\n        Tools.merge(this, settings);\n        this.onCollision = new Signal();\n        this.entity = entity;\n        this.position = Kai.expect(entity, 'position', Vec2);\n        this.velocity = Kai.expect(entity, 'velocity', Vec2);\n        if (this.hasAccel) {\n            this.accel = Kai.expect(entity, 'accel', Vec2);\n        }\n        this.setMass(this.mass);\n    };\n    RadialColider2.accessor = 'body';\n    RadialColider2.className = 'BODY_RADIAL_COLLIDER2';\n    RadialColider2.priority = 100;\n    RadialColider2.post = false;\n    RadialColider2.prototype = {\n        constructor: RadialColider2,\n        setMass: function (newMass) {\n            this.mass = newMass;\n            if (newMass <= 0) {\n                this.invmass = 0;\n            } else {\n                this.invmass = 1 / newMass;\n            }\n        },\n        activate: function () {\n            this.solid = true;\n            this.active = true;\n            if (this.autoAdd) {\n                World.broadphase.add(this);\n            }\n        },\n        disable: function () {\n            this.solid = false;\n            this.active = false;\n            if (this.autoAdd) {\n                World.broadphase.remove(this);\n            }\n        },\n        update: function () {\n            this.velocity.y += World.gravity;\n            if (this.hasAccel) {\n                this.velocity.x += this.accel.x;\n                this.velocity.y += this.accel.y;\n            }\n            this.velocity.truncate(this.maxSpeed);\n            if (this.hasFriction) {\n                this.velocity.x *= World.friction;\n                this.velocity.y *= World.friction;\n            }\n            this.position.x += this.velocity.x * World.elapsed;\n            this.position.y += this.velocity.y * World.elapsed;\n            switch (this.boundaryBehavior) {\n            case PhysicsConstants.BOUNDARY_DISABLE:\n                if (this.position.x < this.radius || this.position.x + this.radius > World.width || this.position.y < this.radius || this.position.y + this.radius > World.height) {\n                    this.onCollision.dispatch(null);\n                }\n                break;\n            case PhysicsConstants.BOUNDARY_BOUNCE:\n                if (this.position.x < this.radius) {\n                    this.position.x = this.radius;\n                    this.velocity.x = -this.velocity.x * this.restitution;\n                } else if (this.position.x + this.radius > World.width) {\n                    this.position.x = World.width - this.radius;\n                    this.velocity.x = -this.velocity.x * this.restitution;\n                }\n                if (this.position.y < this.radius) {\n                    this.position.y = this.radius;\n                    this.velocity.y = -this.velocity.y * this.restitution;\n                } else if (this.position.y + this.radius > World.height) {\n                    this.position.y = World.height - this.radius;\n                    this.velocity.y = -this.velocity.y * this.restitution;\n                }\n                break;\n            case PhysicsConstants.BOUNDARY_WRAP:\n                if (this.position.x < 0) {\n                    this.position.x += World.width;\n                } else if (this.position.x > World.width) {\n                    this.position.x -= World.width;\n                }\n                if (this.position.y < 0) {\n                    this.position.y += World.height;\n                } else if (this.position.y > World.height) {\n                    this.position.y -= World.height;\n                }\n                break;\n            }\n        },\n        debugDraw: function (ctx) {\n            if (World.camera) {\n                DebugDraw.circle(ctx, this.position.x - World.camera.position.x, this.position.y - World.camera.position.y, this.radius);\n            } else {\n                DebugDraw.circle(ctx, this.position.x, this.position.y, this.radius);\n            }\n        },\n        dispose: function () {\n            this.onCollision.dispose();\n            this.entity = null;\n            this.position = null;\n            this.velocity = null;\n            this.onCollision = null;\n        }\n    };\n    return RadialColider2;\n}({}, mh['Kai'], mh['Tools'], mh['World'], mh['PhysicsConstants'], mh['DebugDraw'], mh['Base']);\n","mh['Manifold'] = function () {\n    this.a = null;\n    this.b = null;\n    this.penetration = 0;\n    this.normal = new Vec2();\n};\n","mh['Physics2'] = function (require, Manifold) {\n    var Manifold = mh['Manifold'];\n    return {\n        _scratch: new Vec2(),\n        _normal: new Vec2(),\n        _impulse: new Vec2(),\n        _manifold: new Manifold(),\n        resolve: function (a, b, m) {\n            this._scratch.reset(b.velocity.x - a.velocity.x, b.velocity.y - a.velocity.y);\n            var velAlongNormal = this._scratch.dotProduct(m.normal);\n            if (velAlongNormal > 0) {\n                return;\n            }\n            var e = Math.min(a.restitution, b.restitution);\n            var j = -(1 + e) * velAlongNormal;\n            j /= a.invmass + b.invmass;\n            this._impulse.reset(m.normal.x * j, m.normal.y * j);\n            a.velocity.x -= a.invmass * this._impulse.x;\n            a.velocity.y -= a.invmass * this._impulse.y;\n            b.velocity.x += b.invmass * this._impulse.x;\n            b.velocity.y += b.invmass * this._impulse.y;\n        },\n        testAABBvsAABB: function (a, b) {\n            if (a.min.x > b.max.x)\n                return false;\n            if (a.min.y > b.max.y)\n                return false;\n            if (a.max.x < b.min.x)\n                return false;\n            if (a.max.y < b.min.y)\n                return false;\n            return true;\n        },\n        separateAABBvsAABB: function (a, b) {\n            if (a.max.x < b.min.x || a.min.x > b.max.x)\n                return null;\n            if (a.max.y < b.min.y || a.min.y > b.max.y)\n                return null;\n            this._normal.reset(b.position.x - a.position.x, b.position.y - a.position.y);\n            var a_extent = (a.max.x - a.min.x) / 2;\n            var b_extent = (b.max.x - b.min.x) / 2;\n            var x_overlap = a_extent + b_extent - Math.abs(this._normal.x);\n            if (x_overlap > 0) {\n                a_extent = (a.max.y - a.min.y) / 2;\n                b_extent = (b.max.y - b.min.y) / 2;\n                var y_overlap = a_extent + b_extent - Math.abs(this._normal.y);\n                if (y_overlap > 0) {\n                    if (x_overlap < y_overlap) {\n                        if (this._normal.x < 0) {\n                            this._manifold.normal.reset(-1, 0);\n                        } else {\n                            this._manifold.normal.reset(1, 0);\n                        }\n                        this._manifold.penetration = x_overlap;\n                    } else {\n                        if (this._normal.y < 0) {\n                            this._manifold.normal.reset(0, -1);\n                        } else {\n                            this._manifold.normal.reset(0, 1);\n                        }\n                        this._manifold.penetration = y_overlap;\n                    }\n                    var correctionX = this._manifold.penetration * this._manifold.normal.x;\n                    var correctionY = this._manifold.penetration * this._manifold.normal.y;\n                    var cim = a.invmass + b.invmass;\n                    a.position.x -= correctionX * (a.invmass / cim);\n                    a.position.y -= correctionY * (a.invmass / cim);\n                    b.position.x += correctionX * (b.invmass / cim);\n                    b.position.y += correctionY * (b.invmass / cim);\n                    return this._manifold;\n                }\n            }\n            return null;\n        },\n        testCircleVsCircle: function (a, b) {\n            var dx = b.position.x - a.position.x;\n            var dy = b.position.y - a.position.y;\n            var dist = dx * dx + dy * dy;\n            var radii = a.radius + b.radius;\n            if (dist < radii * radii) {\n                return true;\n            }\n            return false;\n        },\n        separateCircleVsCircle: function (a, b) {\n            var dx = b.position.x - a.position.x;\n            var dy = b.position.y - a.position.y;\n            var dist = dx * dx + dy * dy;\n            var radii = a.radius + b.radius;\n            var rSqr = radii * radii;\n            var cim, j, correctionX, correctionY;\n            if (dist < rSqr) {\n                dist = Math.sqrt(dx * dx + dy * dy);\n                if (dist === 0) {\n                    dist = a.radius + b.radius - 1;\n                    dx = dy = radii;\n                    this._manifold.penetration = a.radius;\n                    this._manifold.normal.reset(1, 0);\n                } else {\n                    this._manifold.penetration = rSqr - dist;\n                    this._manifold.normal.reset(dx, dy).normalize();\n                }\n                j = (radii - dist) / dist;\n                correctionX = dx * j;\n                correctionY = dy * j;\n                cim = a.invmass + b.invmass;\n                a.position.x -= correctionX * (a.invmass / cim);\n                a.position.y -= correctionY * (a.invmass / cim);\n                b.position.x += correctionX * (b.invmass / cim);\n                b.position.y += correctionY * (b.invmass / cim);\n                return this._manifold;\n            }\n            return null;\n        }\n    };\n}({}, mh['Manifold']);\n","mh['CollisionGridScanner'] = function (require, Tools, World, Physics2, Base) {\n    var Tools = mh['Tools'];\n    var World = mh['World'];\n    var Physics = mh['Physics2'];\n    var CollisionGridScanner = function (entity, settings) {\n        mh['Base'].call(this);\n        this.scanRadius = 1;\n        Tools.merge(this, settings);\n        this.onCollision = new Signal();\n        this.entity = entity;\n        this._body = entity.body;\n        this._nearby = new LinkedList();\n        this._grid = World.broadphase;\n    };\n    CollisionGridScanner.accessor = 'collisionScanner';\n    CollisionGridScanner.className = 'COLLISION_SCANNER_RADIAL';\n    CollisionGridScanner.priority = 5;\n    CollisionGridScanner.prototype = {\n        constructor: CollisionGridScanner,\n        activate: function () {\n            this.active = true;\n        },\n        disable: function () {\n            this.active = false;\n        },\n        update: function () {\n            var node, obj, m;\n            this._grid.getNeighbors(this._body, this.scanRadius, this._nearby);\n            node = this._nearby.first;\n            while (node) {\n                obj = node.obj;\n                if (Physics.testCircleVsCircle(obj, this._body)) {\n                    this.onCollision.dispatch(obj);\n                    break;\n                }\n                node = node.next;\n            }\n        },\n        dispose: function () {\n            this.onCollision.dispose();\n            this.entity = null;\n            this.position = null;\n            this.onCollision = null;\n        }\n    };\n    return CollisionGridScanner;\n}({}, mh['Tools'], mh['World'], mh['Physics2'], mh['Base']);\n","mh['Health'] = function (require, Tools, Base) {\n    var Tools = mh['Tools'];\n    var Health = function (entity, settings) {\n        mh['Base'].call(this);\n        this.max = 100;\n        this.overage = 0;\n        this.alive = false;\n        this.active = false;\n        Tools.merge(this, settings);\n        this.onDeath = new Signal();\n        this.onDamage = new Signal();\n        this.onHeal = new Signal();\n        this.onFull = new Signal();\n        this.onActivate = new Signal();\n        this.entity = entity;\n        this._meter = 0;\n    };\n    Health.accessor = 'health';\n    Health.className = 'HEALTH';\n    Health.priority = 1;\n    Health.prototype = {\n        constructor: Health,\n        activate: function () {\n            this._meter = this.max;\n            this.alive = true;\n            this.onActivate.dispatch(this._meter, this.entity);\n        },\n        change: function (amount) {\n            if (!this.alive)\n                return 0;\n            this._meter += amount;\n            if (this._meter <= 0) {\n                this._meter = 0;\n                this.alive = false;\n                this.onDeath.dispatch(amount, this.entity);\n            } else {\n                if (this._meter > this.max + this.overage) {\n                    this._meter = this.max;\n                    this.onFull.dispatch(amount);\n                }\n                if (amount < 0)\n                    this.onDamage.dispatch(amount);\n                else\n                    this.onHeal.dispatch(amount);\n            }\n            return this._meter;\n        },\n        drain: function (amount) {\n            if (!this.alive)\n                return 0;\n            if (this._meter > this.max) {\n                this._meter -= amount;\n                if (this._meter <= this.max) {\n                    this._meter = this.max;\n                    this.onFull.dispatch(amount);\n                }\n            }\n            return this._meter;\n        },\n        dispose: function () {\n            this.onDeath.dispose();\n            this.onDamage.dispose();\n            this.onHeal.dispose();\n            this.onFull.dispose();\n            this.entity = null;\n            this.deathSignal = null;\n            this.onDamage = null;\n            this.onHeal = null;\n            this.onFull = null;\n        }\n    };\n    return Health;\n}({}, mh['Tools'], mh['Base']);\n","mh['TwinStickMovement'] = function (require, Tools, Base) {\n    var Tools = mh['Tools'];\n    var TwinStickMovement = function (entity, settings) {\n        mh['Base'].call(this);\n        this.speed = 1;\n        this.pad = null;\n        Tools.merge(this, settings);\n        this.entity = entity;\n        this.accel = entity.accel;\n        this.rotation = entity.rotation;\n        this.active = false;\n    };\n    TwinStickMovement.accessor = 'input';\n    TwinStickMovement.className = 'INPUT_TWINSTICK';\n    TwinStickMovement.priority = 20;\n    TwinStickMovement.prototype = {\n        constructor: TwinStickMovement,\n        activate: function () {\n            this.accel.x = this.accel.y = 0;\n            this.rotation.x = this.rotation.y = 0;\n            this.active = true;\n        },\n        update: function () {\n            this.accel.copy(this.pad.leftAxis).multiplyScalar(this.speed);\n            this.rotation.copy(this.pad.rightAxis);\n        },\n        dispose: function () {\n            this.entity = null;\n            this.accel = null;\n            this.rotation = null;\n        }\n    };\n    return TwinStickMovement;\n}({}, mh['Tools'], mh['Base']);\n","mh['Timer'] = function (require, Tools, Base) {\n    var Tools = mh['Tools'];\n    var Timer = function (entity, settings) {\n        mh['Base'].call(this);\n        this.repeat = -1;\n        this.immediateDispatch = false;\n        this.interval = 1000;\n        Tools.merge(this, settings);\n        this.onInterval = new Signal();\n        this.entity = entity;\n        this._timer = 0;\n        this._numTicks = 0;\n        this._currentRepeat = this.repeat;\n        this.disable();\n    };\n    Timer.accessor = 'timer';\n    Timer.className = 'TIMER';\n    Timer.priority = 13;\n    Timer.prototype = {\n        constructor: Timer,\n        activate: function () {\n            this._timer = performance.now();\n            this.active = true;\n            this._currentRepeat = this.repeat;\n            this._numTicks = 0;\n            if (this.immediateDispatch) {\n                this._numTicks++;\n                this.onInterval.dispatch(this._numTicks);\n            }\n        },\n        disable: function () {\n            this.active = false;\n        },\n        reset: function () {\n            this._timer = performance.now();\n            this._numTicks = 0;\n            if (this.active && this.immediateDispatch) {\n                this._numTicks++;\n                this.onInterval.dispatch(this._numTicks);\n            }\n        },\n        update: function () {\n            if (performance.now() - this._timer >= this.interval) {\n                this._numTicks++;\n                this.onInterval.dispatch(this._numTicks);\n                if (this.repeat !== -1 && this._currentRepeat-- === 0) {\n                    this.disable();\n                    return;\n                }\n                this._timer = performance.now();\n            }\n        },\n        dispose: function () {\n            this.onInterval.dispose();\n            this.onInterval = null;\n            this.entity = null;\n        }\n    };\n    return Timer;\n}({}, mh['Tools'], mh['Base']);\n","/**\n * Class description\n */\nmh['GridTargeter'] = function (require, World, Tools, Base) {\n    var World = mh['World'];\n    var Tools = mh['Tools'];\n    var GridTargeter = function (entity, settings) {\n        mh['Base'].call(this);\n        this.searchInterval = 1000;\n        this.scanRadius = 400;\n        this.collisionId = entity.collisionId;\n        this.target = null;\n        Tools.merge(this, settings);\n        this.entity = entity;\n        this._nearby = new LinkedList();\n        this._grid = World.broadphase;\n        this._timer = 0;\n        this.position = entity.position;\n    };\n    GridTargeter.accessor = 'gridTargeter';\n    GridTargeter.className = 'GRID_TARGETER';\n    GridTargeter.priority = 10;\n    GridTargeter.prototype = {\n        constructor: GridTargeter,\n        activate: function () {\n            this.active = true;\n            this.target = null;\n            this.collisionId = this.entity.collisionId;\n            this._findTarget();\n        },\n        disable: function () {\n            this.active = false;\n            this.target = null;\n        },\n        update: function () {\n            if (performance.now() - this._timer >= this.searchInterval) {\n                this._findTarget();\n                this._timer = performance.now();\n            }\n        },\n        dispose: function () {\n            this.entity = null;\n            this.position = null;\n        },\n        _findTarget: function () {\n            var node, obj, m;\n            this._nearby.clear();\n            this._grid.getNearby(this.position, this.scanRadius, this._nearby);\n            node = this._nearby.first;\n            while (node) {\n                obj = node.obj;\n                if (obj && obj.entity.id !== this.entity.id) {\n                    this.target = obj;\n                    return;\n                }\n                node = node.next;\n            }\n            this.target = null;\n        }\n    };\n    return GridTargeter;\n}({}, mh['World'], mh['Tools'], mh['Base']);\n","mh['MathTools'] = {\n    PI: Math.PI,\n    TAU: Math.PI * 2,\n    clamp: function (val, min, max) {\n        return Math.max(min, Math.min(max, val));\n    },\n    sign: function (val) {\n        return number && number / Math.abs(number);\n    },\n    random: function (min, max) {\n        if (arguments.length === 1) {\n            return Math.random() * min - min * 0.5;\n        }\n        return Math.random() * (max - min) + min;\n    },\n    randomInt: function (min, max) {\n        if (arguments.length === 1) {\n            return Math.floor(Math.random() * min - min * 0.5);\n        }\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    },\n    getShortRotation: function (angle) {\n        angle %= this.TAU;\n        if (angle > this.PI) {\n            angle -= this.TAU;\n        } else if (angle < -this.PI) {\n            angle += this.TAU;\n        }\n        return angle;\n    }\n};\n","/*\n\tControls the acceleration of an entity and enables steering behaviors to be used.\n*/\nmh['Boid'] = function (require, Kai, Tools, World, MathTools, Base) {\n    var Kai = mh['Kai'];\n    var Tools = mh['Tools'];\n    var World = mh['World'];\n    var MathTools = mh['MathTools'];\n    var Boid = function (entity, settings) {\n        mh['Base'].call(this);\n        this.maxForce = 10;\n        this.slowingRadius = 50;\n        this.pathArriveRadius = 50;\n        this.groupID = 0;\n        this.flockRadius = 160;\n        this.maxCohesion = 140;\n        this.minSeparation = 70;\n        this.angleJitter = 0.9;\n        this.targetDistance = 20;\n        this.targetRadius = 20;\n        Tools.merge(this, settings);\n        this.entity = entity;\n        this.steeringForce = new Vec2(MathTools.random(this.maxForce), MathTools.random(this.maxForce));\n        this.maxSpeed = this.entity.maxSpeed || this.maxForce;\n        if (entity.body) {\n            this.maxSpeed = entity.body.maxSpeed;\n        }\n        this._wanderAngle = 0;\n        this._currentPathNode = 0;\n        this._pathDir = 1;\n        this._arrived = false;\n        this.position = Kai.expect(entity, 'position', Vec2);\n        this.rotation = Kai.expect(entity, 'rotation', Vec2);\n        this.velocity = Kai.expect(entity, 'velocity', Vec2);\n        this.groupControl = new Signal();\n    };\n    Boid.accessor = 'boid';\n    Boid.className = 'BOID';\n    Boid.priority = 95;\n    Boid.post = false;\n    Boid.prototype = {\n        constructor: Boid,\n        activate: function () {\n            this.active = true;\n            this._currentPathNode = 0;\n            this._pathDir = 1;\n            this._arrived = false;\n        },\n        disable: function () {\n            this.active = false;\n        },\n        update: function () {\n            this.steeringForce.truncate(this.maxForce);\n            this.steeringForce.multiplyScalar(this.entity.body.invmass);\n            this.velocity.x += this.steeringForce.x;\n            this.velocity.y += this.steeringForce.y;\n            this.rotation.x = this.velocity.x;\n            this.rotation.y = this.velocity.y;\n            this.steeringForce.x = 0;\n            this.steeringForce.y = 0;\n        },\n        dispose: function () {\n            this.groupControl.dispose();\n            this.groupControl = null;\n            this.entity = null;\n            this.steeringForce = null;\n            this.position = null;\n            this.rotation = null;\n            this.velocity = null;\n        }\n    };\n    return Boid;\n}({}, mh['Kai'], mh['Tools'], mh['World'], mh['MathTools'], mh['Base']);\n","mh['StackFSM'] = function (require, Tools, Base) {\n    var Tools = mh['Tools'];\n    var StackFSM = function (entity) {\n        mh['Base'].call(this);\n        this.state = null;\n        this.stack = [];\n        this.entity = entity;\n        this.stateChanged = new Signal();\n        this._activeContext = null;\n        this._activeFunction = null;\n        this._prevFunction = null;\n    };\n    StackFSM.accessor = 'stackFSM';\n    StackFSM.className = 'STACK_FSM';\n    StackFSM.priority = 5;\n    StackFSM.post = false;\n    StackFSM.prototype = {\n        constructor: StackFSM,\n        activate: function () {\n            this.active = true;\n        },\n        disable: function () {\n            this.active = false;\n            this.reset();\n        },\n        reset: function () {\n            this.stack.length = 0;\n            this._prevFunction = null;\n            this._activeFunction = null;\n        },\n        pushState: function (state, ctx) {\n            if (state !== this._activeFunction) {\n                this.stack.push(state);\n                this._activeContext = ctx;\n                if (!this.active) {\n                    this.activate();\n                }\n            }\n        },\n        popState: function () {\n            this.stack.pop();\n            this._activeFunction = this.stack.length ? this.stack[this.stack.length - 1] : null;\n            if (!this._activeFunction) {\n                this.stateChanged.dispatch(this.state, 'null');\n                this._prevFunction = null;\n                this.disable();\n            }\n        },\n        update: function () {\n            this._activeFunction = this.stack.length ? this.stack[this.stack.length - 1] : null;\n            if (this._activeFunction) {\n                if (this._activeFunction !== this._prevFunction) {\n                    this.state = this._activeFunction.name;\n                    this.stateChanged.dispatch(this._prevFunction ? this._prevFunction.name : 'null', this.state);\n                    this._prevFunction = this._activeFunction;\n                }\n                this._activeFunction.call(this._activeContext);\n            }\n        },\n        dispose: function () {\n            this.entity = null;\n            this._activeFunction = null;\n            this._prevFunction = null;\n            this.stack = null;\n            this.stateChanged.dispose();\n            this.stateChanged = null;\n        }\n    };\n    return StackFSM;\n}({}, mh['Tools'], mh['Base']);\n","/*\n\trequirejs passes in the loaded classes into the callback's arguments pseudo-array,\n\tso we take advantage of that and go through that array, creating a plain object\n\twrapper for each component that holds vital information about it, which we use in Engine\n\tand, in fact, by all entities as well. Check out Kai.registerComponents to see what I'm\n\ttalking about.\n\t\n\tThose plain object wrappers (which I call component \"definitions\") allows us to dynamically\n\taugment entities at runtime, since we reference the definition and not the prototype directly.\n\t\n\tKai creates an array of LinkedLists. Each List is a component type, containing all the instances\n\tof that type. The Engine grabs and loops through every List and calls `update()` anything in it.\n\t\n\tA lot of assumptions must be made for this to work, so I created the Templates to make building\n\tstuff a lot easier, and not have to remember what's what.\n\t\n\t@author Corey Birnbaum\n*/\nmh['VonComponents'] = function (AABB2, AABB3, RadialCollider2, CollisionGridScanner, Health, TwinStickMovement, Timer, GridTargeter, Boid, StackFSM) {\n    return mh['Kai'].registerComponents(arguments);\n}(mh['AABB2'], mh['AABB3'], mh['RadialCollider2'], mh['CollisionGridScanner'], mh['Health'], mh['TwinStickMovement'], mh['Timer'], mh['GridTargeter'], mh['Boid'], mh['StackFSM']);\n","mh['CollisionGrid'] = function (require, Kai, World, Physics2) {\n    var Kai = mh['Kai'];\n    var World = mh['World'];\n    var Physics = mh['Physics2'];\n    return function CollisionGrid(cellSize) {\n        this.cellPixelSize = cellSize;\n        this.widthInCells = Math.floor(World.width / cellSize) + 1;\n        this.heightInCells = Math.floor(World.height / cellSize) + 1;\n        this.numCells = this.widthInCells * this.heightInCells;\n        var _self = this, _nearbyList = new LinkedList(), _cells = [], _lengths = [], _itemList = new LinkedList(), _sizeMulti = 1 / this.cellPixelSize;\n        var _normal = new Vec2(), _rv = new Vec2(), _impulse = new Vec2(), _mtd = new Vec2(), _difference = new Vec2();\n        this.update = function () {\n            var i, cell, cellPos, cellNode, m, node, item, other;\n            var x, y, minX, minY, maxX, maxY, gridRadius;\n            for (i = 0; i < this.numCells; i++) {\n                _cells[i].clear();\n            }\n            node = _itemList.first;\n            while (node) {\n                item = node.obj;\n                if (!item.solid) {\n                    node = node.next;\n                    continue;\n                }\n                gridRadius = Math.ceil(item.radius * _sizeMulti);\n                itemX = ~~(item.position.x * _sizeMulti);\n                itemY = ~~(item.position.y * _sizeMulti);\n                minX = itemX - gridRadius;\n                if (minX < 0)\n                    minX = 0;\n                minY = itemY - gridRadius;\n                if (minY < 0)\n                    minY = 0;\n                maxX = itemX + gridRadius;\n                if (maxX > this.widthInCells)\n                    maxX = this.widthInCells;\n                maxY = itemY + gridRadius;\n                if (maxY > this.heightInCells)\n                    maxY = this.heightInCells;\n                for (x = minX; x <= maxX; x++) {\n                    for (y = minY; y <= maxY; y++) {\n                        cellPos = x * this.heightInCells + y;\n                        cell = _cells[cellPos];\n                        if (!cell)\n                            continue;\n                        cellNode = cell.first;\n                        while (cellNode) {\n                            other = cellNode.obj;\n                            if (!other.solid || other.collisionId === item.collisionId) {\n                                cellNode = cellNode.next;\n                                continue;\n                            }\n                            m = Physics.separateCircleVsCircle(item, other);\n                            if (m) {\n                                Physics.resolve(item, other, m);\n                                item.onCollision.dispatch(other, m);\n                                other.onCollision.dispatch(item, m);\n                            }\n                            cellNode = cellNode.next;\n                        }\n                        _cells[cellPos].add(item);\n                    }\n                }\n                node = node.next;\n            }\n        };\n        this.draw = function (offsetX, offsetY) {\n            var i, j, node, ctx = Kai.debugCtx;\n            offsetX = offsetX || 0;\n            offsetY = offsetY || 0;\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n            for (i = 0; i < this.widthInCells; i++) {\n                for (j = 0; j < this.heightInCells; j++) {\n                    ctx.strokeRect(i * this.cellPixelSize + offsetX, j * this.cellPixelSize + offsetY, this.cellPixelSize, this.cellPixelSize);\n                }\n            }\n            node = _itemList.first;\n            while (node) {\n                node.obj.debugDraw(ctx);\n                node = node.next;\n            }\n        };\n        this.add = function (obj) {\n            _itemList.add(obj);\n        };\n        this.remove = function (obj) {\n            _itemList.remove(obj);\n        };\n        this.getNeighbors = function (body, pixelRadius, list) {\n            var x, y, dx, dy, cell, node, other, cellPos, minX, minY, maxX, maxY, influence = pixelRadius * pixelRadius, gridRadius = Math.ceil(pixelRadius * _sizeMulti), pos = body.position, itemX = ~~(pos.x * _sizeMulti), itemY = ~~(pos.y * _sizeMulti);\n            if (!list) {\n                list = _nearbyList;\n            }\n            list.clear();\n            minX = itemX - gridRadius;\n            if (minX < 0)\n                minX = 0;\n            minY = itemY - gridRadius;\n            if (minY < 0)\n                minY = 0;\n            maxX = itemX + gridRadius;\n            if (maxX > this.widthInCells)\n                maxX = this.widthInCells;\n            maxY = itemY + gridRadius;\n            if (maxY > this.heightInCells)\n                maxY = this.heightInCells;\n            for (x = minX; x <= maxX; x++) {\n                for (y = minY; y <= maxY; y++) {\n                    cellPos = x * this.heightInCells + y;\n                    cell = _cells[cellPos];\n                    if (!cell)\n                        continue;\n                    node = cell.first;\n                    while (node) {\n                        other = node.obj;\n                        if (!other.solid || other.collisionId === body.collisionId) {\n                            node = node.next;\n                            continue;\n                        }\n                        dx = pos.x - other.position.x;\n                        dy = pos.y - other.position.y;\n                        if (dx * dx + dy * dy <= influence) {\n                            list.add(other);\n                        }\n                        node = node.next;\n                    }\n                }\n            }\n            return list;\n        };\n        this.getNearby = function (pos, pixelRadius, list) {\n            var x, y, dx, dy, cell, node, other, cellPos, minX, minY, maxX, maxY, influence = pixelRadius * pixelRadius, gridRadius = Math.ceil(pixelRadius * _sizeMulti), itemX = ~~(pos.x * _sizeMulti), itemY = ~~(pos.y * _sizeMulti);\n            if (!list) {\n                _nearbyList.clear();\n                list = _nearbyList;\n            }\n            minX = itemX - gridRadius;\n            if (minX < 0)\n                minX = 0;\n            minY = itemY - gridRadius;\n            if (minY < 0)\n                minY = 0;\n            maxX = itemX + gridRadius;\n            if (maxX > this.widthInCells)\n                maxX = this.widthInCells;\n            maxY = itemY + gridRadius;\n            if (maxY > this.heightInCells)\n                maxY = this.heightInCells;\n            for (x = minX; x <= maxX; x++) {\n                for (y = minY; y <= maxY; y++) {\n                    cellPos = x * this.heightInCells + y;\n                    cell = _cells[cellPos];\n                    if (!cell)\n                        continue;\n                    node = cell.first;\n                    while (node) {\n                        other = node.obj;\n                        dx = pos.x - other.position.x;\n                        dy = pos.y - other.position.y;\n                        if (dx * dx + dy * dy <= influence) {\n                            list.add(other);\n                        }\n                        node = node.next;\n                    }\n                }\n            }\n            return list;\n        };\n        this.getAllInArea = function (startX, startY, endX, endY, list) {\n            var x, y, cell, node, other, cellPos, minX, minY, maxX, maxY;\n            if (!list) {\n                _nearbyList.clear();\n                list = _nearbyList;\n            }\n            minX = ~~(startX * _sizeMulti);\n            minY = ~~(startY * _sizeMulti);\n            maxX = endX * _sizeMulti + 1 >> 0;\n            if (maxX > this.widthInCells)\n                maxX = this.widthInCells;\n            maxY = endY * _sizeMulti + 1 >> 0;\n            if (maxY > this.heightInCells)\n                maxY = this.heightInCells;\n            for (x = minX; x <= maxX; x++) {\n                for (y = minY; y <= maxY; y++) {\n                    cellPos = x * this.heightInCells + y;\n                    cell = _cells[cellPos];\n                    if (!cell)\n                        continue;\n                    node = cell.first;\n                    while (node) {\n                        other = node.obj;\n                        node = node.next;\n                        if (other.position.x > endX || other.position.x < startX || other.position.y > endY || other.position.y < startY) {\n                            continue;\n                        }\n                        list.add(other);\n                    }\n                }\n            }\n            return list;\n        };\n        this.log = function () {\n            console.log('Cells: ' + _cells.length);\n        };\n        init();\n        function init() {\n            var i, j;\n            for (i = 0; i < _self.numCells; i++) {\n                _cells[i] = new LinkedList();\n            }\n            console.log('[CollisionGrid] ' + _self.widthInCells + 'x' + _self.heightInCells + ': ' + _self.numCells + ' cells');\n        }\n    };\n}({}, mh['Kai'], mh['World'], mh['Physics2']);\n","// DOM utility functions\nmh['DOMTools'] = {\n    copySpatial: function (fromElement, toElement) {\n        var rect = fromElement.getBoundingClientRect(), aStyle = fromElement.style, bStyle = toElement.style;\n        bStyle.position = 'absolute';\n        bStyle.top = rect.top + 'px';\n        bStyle.left = rect.left + 'px';\n        if (fromElement.nodeName === 'CANVAS') {\n            toElement.width = fromElement.width;\n            toElement.height = fromElement.height;\n        } else {\n            bStyle.width = fromElement.offsetWidth;\n            bStyle.height = fromElement.offsetHeight;\n        }\n    }\n};\n","mh['DualPool'] = function (require) {\n    var DualPool = function (classConstructor, instanceSettings, initSize) {\n        var obj;\n        this._Class = classConstructor;\n        this._freeList = new LinkedList();\n        this._busyList = new LinkedList();\n        this._settings = instanceSettings || {};\n        this._settings.pool = this;\n        this.size = initSize;\n        for (var i = 0; i < this.size; i++) {\n            this._freeList.add(new this._Class(this._settings));\n        }\n    };\n    DualPool.prototype = {\n        constructor: DualPool,\n        get: function () {\n            var obj;\n            if (this._freeList.length) {\n                obj = this._freeList.pop();\n                this._busyList.add(obj);\n                return obj;\n            }\n            obj = new this._Class(this._settings);\n            this._busyList.add(obj);\n            this.size++;\n            return obj;\n        },\n        recycle: function (obj) {\n            if (this._busyList.has(obj)) {\n                this._busyList.remove(obj);\n                this._freeList.add(obj);\n            }\n        },\n        freeAll: function () {\n            var obj, node = this._busyList.first;\n            while (node) {\n                obj = node.obj;\n                this._busyList.remove(obj);\n                this._freeList.add(obj);\n                node = node.next;\n            }\n        },\n        dispose: function () {\n            this._freeList.dispose();\n            this._busyList.dispose();\n            this._freeList = null;\n            this._busyList = null;\n            this._Class = null;\n            this._settings = null;\n        },\n        toString: function () {\n            return '[DualPool size: ' + this.size + ', free: ' + this._freeList.length + ', busy: ' + this._busyList.length + ']';\n        }\n    };\n    return DualPool;\n}({});\n"],"sourceRoot":"/source/"}